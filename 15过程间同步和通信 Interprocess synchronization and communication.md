# 15. 过程间同步和通信
## 15.1 概述
本章描述以下内容：
 - 信号量
 - 信箱
 - 命名事件

## 15.2 总览
高级和易于使用的同步和通信机制对于控制用于建模复杂系统或高度反应性测试台的动态进程之间发生的各种各样的交互至关重要。

基本的同步机制是命名事件类型，以及事件触发器和事件控制构造（即，`->` 和 `@`）。这种类型的控制仅限于静态对象。它足以用于硬件级别和简单系统级别的同步，但不足以满足高度动态、反应性测试台的需求。

SystemVerilog 还提供了一组强大且易于使用的同步和通信机制，这些机制可以动态创建和回收。这组机制包括一个信号量内置类，用于同步和互斥访问共享资源，以及一个信箱内置类，用作进程之间的通信通道。

信号量和信箱是内置类型；尽管如此，它们是类，可以用作派生其他更高级类的基类。这些内置类位于内置的 std 包中（参见 26.7）；因此，它们可以在任何其他作用域中由用户代码重新定义。

## 15.3 信号量
从概念上讲，信号量是一个桶。当分配信号量时，创建一个包含固定数量的钥匙的桶。使用信号量的进程必须在继续执行之前从桶中获取一个钥匙。如果特定进程需要一个钥匙，只有固定数量的该进程的发生可以同时进行。所有其他进程必须等待，直到足够数量的钥匙被返回到桶中。信号量通常用于互斥、访问控制共享资源和基本同步。

创建信号量的示例如下：
```verilog
semaphore smTx;
```

信号量是一个内置类，提供以下方法：
 - 使用指定数量的钥匙创建信号量：`new()`
 - 从桶中获取一个或多个钥匙：`get()`
 - 将一个或多个钥匙返回到桶中：`put()`
 - 尝试获取一个或多个钥匙而不阻塞：`try_get()`

### 15.3.1 New()
使用 `new()` 方法创建信号量。

`new()` 的原型如下：
```verilog
function new(int keyCount = 0);
```

`keyCount` 指定信号量桶中最初分配的钥匙数量。当将比移除的钥匙更多的钥匙放入信号量时，桶中的钥匙数量可以超过 `keyCount`。`keyCount` 的默认值为 0。

`new()` 函数返回信号量句柄。

### 15.3.2 Put()
信号量 `put()` 方法用于将钥匙返回到信号量。

`put()` 的原型如下：
```verilog
function void put(int keyCount = 1);
```

`keyCount` 指定要返回到信号量的钥匙数量。默认值为 1。

调用 `semaphore.put()` 函数时，指定数量的钥匙将返回到信号量。如果一个进程被挂起等待钥匙，那么如果返回了足够数量的钥匙，该进程将执行。

### 15.3.3 Get()
信号量 `get()` 方法用于从信号量获取指定数量的钥匙。

`get()` 的原型如下：
```verilog
task get(int keyCount = 1);
```

`keyCount` 指定要从信号量获取的钥匙数量。默认值为 1。

如果指定数量的钥匙可用，则该方法返回并继续执行。如果指定数量的钥匙不可用，则进程将阻塞，直到钥匙可用。

信号量等待队列是先进先出（FIFO）的。这并不保证进程到达队列的顺序，只保证它们到达的顺序将由信号量保留。

### 15.3.4 Try_get()
信号量 `try_get()` 方法用于从信号量获取指定数量的钥匙，但不阻塞。

`try_get()` 的原型如下：
```verilog
function int try_get(int keyCount = 1);
```

`keyCount` 指定要从信号量获取的钥匙数量。默认值为 1。

如果指定数量的钥匙可用，则该方法返回正整数并继续执行。如果指定数量的钥匙不可用，则该方法返回 0。

## 15.4 信箱
信箱是一种通信机制，允许进程之间交换消息。数据可以由一个进程发送到信箱，然后由另一个进程检索。

从概念上讲，信箱的行为类似于真实的信箱。当信件被投递并放入信箱时，一个人可以检索信件（以及其中存储的任何数据）。但是，如果信件在检查信箱时尚未投递，那么该人必须选择是等待信件还是在以后的行程中检索信件。类似地，SystemVerilog 的信箱提供了进程以受控方式传输和检索数据的机制。信箱是创建为具有有界或无界队列大小的。有界信箱在包含边界数量的消息时变满。试图将消息放入满信箱的进程将被挂起，直到信箱队列中有足够的空间。无界信箱在发送操作中永远不会挂起线程。

创建信箱的示例如下：
```verilog
mailbox mbxRcv;
```

信箱是一个内置类，提供以下方法：
 - 创建信箱：`new()`
 - 将消息放入信箱：`put()`
 - 尝试将消息放入信箱而不阻塞：`try_put()`
 - 从信箱检索消息：`get()` 或 `peek()`
 - 尝试从信箱检索消息而不阻塞：`try_get()` 或 `try_peek()`
 - 检索信箱中的消息数量：`num()`

### 15.4.1 New()
使用 `new()` 方法创建信箱。

`new()` 的原型如下：
```verilog
function new(int bound = 0);
```

`new()` 函数返回信箱句柄。如果 `bound` 参数为 0，则信箱是无界的（默认值），并且 `put()` 操作永远不会阻塞。如果 `bound` 不为零，则表示信箱队列的大小。

`bound` 必须为正数。负数边界是非法的，可能导致不确定的行为，但实现可以发出警告。

### 15.4.2 Num()
可以通过 `num()` 方法获取信箱中的消息数量。

`num()` 的原型如下：
```verilog
function int num();
```

`num()` 方法返回当前信箱中的消息数量。

返回值应谨慎使用，因为它仅在下一次在信箱上执行 `get()` 或 `put()` 之前有效。这些信箱操作可以来自执行 `num()` 方法的进程之外的不同进程。因此，返回值的有效性取决于其他方法开始和结束的时间。

### 15.4.3 Put()
`put()` 方法将消息放入信箱。

`put()` 的原型如下：
```verilog
task put(singular message);
```

`message` 是任何单一表达式，包括对象句柄。

`put()` 方法以严格的 FIFO 顺序将消息存储在信箱中。如果信箱是使用有界队列创建的，则进程将被挂起，直到队列中有足够的空间。

### 15.4.4 Try_put()
`try_put()` 方法尝试将消息放入信箱。

`try_put()` 的原型如下：
```verilog
function int try_put(singular message);
```

`message` 是任何单一表达式，包括对象句柄。

`try_put()` 方法以严格的 FIFO 顺序将消息存储在信箱中。此方法仅对有界信箱有意义。如果信箱未满，则将指定的消息放入信箱，并返回正整数。如果信箱已满，则方法返回 0。

### 15.4.5 Get()
`get()` 方法从信箱中检索消息。

`get()` 的原型如下：
```verilog
task get(ref singular message);
```

`message` 可以是任何单一表达式，并且必须是有效的左表达式。

`get()` 方法从信箱中检索一个消息，即从信箱队列中删除一个消息。如果信箱为空，则当前进程将阻塞，直到在信箱中放入消息。如果消息变量的类型与信箱中的消息类型不等效，则会生成运行时错误。

非参数化信箱是无类型的（参见 15.4.9），即单个信箱可以发送和接收不同类型的数据。因此，除了发送的数据（即，消息队列）之外，信箱实现还应保留 `put()` 放置的消息数据类型。这是为了使运行时类型检查能够检测到类型不匹配。

信箱等待队列是 FIFO 的。这并不保证进程到达队列的顺序，只保证信箱保留它们的到达顺序。

### 15.4.6 Try_get()
`try_get()` 方法尝试从信箱中检索消息而不阻塞。

`try_get()` 的原型如下：
```verilog
function int try_get(ref singular message);
```

`message` 可以是任何单一表达式，并且必须是有效的左表达式。

`try_get()` 方法尝试从信箱中检索一个消息。如果信箱为空，则该方法返回 0。如果消息变量的类型与信箱中的消息类型不等效，则该方法返回负整数。如果消息可用且消息类型与消息变量的类型等效，则检索消息，并返回正整数。

### 15.4.7 Peek()
`peek()` 方法从信箱中复制消息，而不从队列中删除消息。

`peek()` 的原型如下：
```verilog
task peek(ref singular message);
```

`message` 可以是任何单一表达式，并且必须是有效的左表达式。

`peek()` 方法从信箱中复制一个消息，而不从信箱队列中删除消息。如果信箱为空，则当前进程将阻塞，直到在信箱中放入消息。如果消息变量的类型与信箱中的消息类型不等效，则会生成运行时错误。

调用 `peek()` 方法也可能导致一个消息解除阻塞多个进程。只要消息保留在信箱队列中，任何在 `peek()` 或 `get()` 操作中阻塞的进程都将解除阻塞。

### 15.4.8 Try_peek()
`try_peek()` 方法尝试从信箱中复制消息，而不阻塞。

`try_peek()` 的原型如下：
```verilog
function int try_peek(ref singular message);
```

`message` 可以是任何单一表达式，并且必须是有效的左表达式。

`try_peek()` 方法尝试从信箱中复制一个消息，而不从信箱队列中删除消息。如果信箱为空，则该方法返回 0。如果消息变量的类型与信箱中的消息类型不等效，则该方法返回负整数。如果消息可用且其类型与消息变量的类型等效，则复制消息，并返回正整数。

### 15.4.9 参数化信箱
默认信箱是无类型的，即单个信箱可以发送和接收任何类型的数据。这是一种非常强大的机制，但不幸的是，由于消息和用于检索消息的变量类型不匹配（类型不等效），可能导致运行时错误。通常，信箱用于传输特定消息类型，因此在编译时检测到所有类型不匹配是有用的。

参数化信箱使用与参数化类（参见 8.25）、模块和接口相同的参数机制：
```verilog
mailbox #(type = dynamic_type)
```

`dynamic_type` 表示一种特殊类型，可以进行运行时类型检查（默认值）。

通过指定类型声明特定类型的参数化信箱：
```verilog
typedef mailbox #(string) s_mbox;

s_mbox sm = new;
string s;

sm.put("hello");
...
sm.get(s); // s <- "hello"
```

参数化信箱提供与动态信箱相同的标准方法：`num()`、`new()`、`get()`、`peek()`、`put()`、`try_get()`、`try_peek()`、`try_put()`。

参数化信箱与通用（动态）信箱之间的唯一区别在于，对于参数化信箱，编译器验证对 `put`、`try_put`、`peek`、`try_peek`、`get` 和 `try_get` 方法的调用使用与信箱类型等效的参数类型，以便所有类型不匹配都由编译器捕获而不是在运行时捕获。

## 15.5 命名事件
声明为事件数据类型的标识符称为 *命名事件*。命名事件可以显式触发。它可以在事件表达式中使用，以控制相同方式中过程语句的执行，如 9.4.2 中所述的事件控制。命名事件也可以用作从另一个命名事件分配的句柄。

命名事件提供了对底层同步对象的句柄。当进程等待事件被触发时，进程被放置在同步对象内维护的队列中。进程可以通过使用 `@` 运算符或使用 `wait()` 构造等待命名事件被触发。

### 15.5.1 触发事件
通过使用以下 15-1 语法的事件触发语句来触发事件：
---
```verilog
event_trigger ::= // from A.6.5
-> hierarchical_event_identifier ;
| ->> [ delay_or_event_control ] hierarchical_event_identifier ;
```
---
语法 15-1—事件触发语法（摘自附录 A）

在事件控制表达式中更改命名事件数组的索引不会触发事件。

通过 `->` 运算符触发的命名事件会解除所有当前等待该事件的进程。当触发时，命名事件的行为类似于一次触发，即触发状态本身不可观察，只能观察其效果。这类似于边缘可以触发触发器，但无法确定边缘的状态，即 `if (posedge clock)` 是非法的。

使用 `->>` 运算符触发非阻塞事件。`->>` 运算符的效果是，语句在不阻塞的情况下执行，并在延迟控制到期或事件控制发生的时间内创建一个非阻塞赋值更新事件。此更新事件的效果应该是在模拟周期的 NBA 区域中触发引用事件。

### 15.5.2 等待事件
等待事件被触发的基本机制是通过事件控制运算符 `@`。
```verilog
@ hierarchical_event_identifier;
```

`@` 运算符阻塞调用进程，直到给定事件被触发。

为了使触发可以解除等待事件的进程，等待进程必须在触发进程执行触发运算符 `->` 之前执行 `@` 语句。如果触发先执行，则等待进程保持阻塞。

### 15.5.3 持久触发：触发属性
SystemVerilog 可以区分事件触发本身（瞬时的）和事件的触发状态，该状态在整个时间步长（即，直到仿真时间前进）中持续。`triggered` 事件属性允许用户检查此状态。

触发属性使用类似方法的语法调用：
```verilog
hierarchical_event_identifier.triggered
```

如果给定事件在当前时间步骤中被触发，则 `triggered` 事件属性计算为 true（1'b1），否则为 false（1'b0）。如果 `event_identifier` 为 null，则 `triggered` 事件属性计算为 false。

`triggered` 事件属性在 `wait` 构造的上下文中使用时最有用：
```verilog
wait ( hierarchical_event_identifier.triggered )
```

使用此机制，事件触发器应解除等待事件的进程，无论等待和触发进程的执行顺序如何。因此，`triggered` 事件属性有助于消除等待和触发进程同时发生时发生的常见竞争条件。等待事件的进程可能会或可能不会解除阻塞，具体取决于等待和触发进程的执行顺序。然而，等待触发状态的进程始终解除阻塞，无论等待和触发操作的执行顺序如何。

示例：
```verilog
event done, blast; // 声明两个新事件
event done_too = done; // 将 done_too 声明为 done 的别名

task trigger( event ev );
    -> ev;
endtask

...

fork
    @ done_too; // 通过 done_too 等待 done
    #1 trigger( done ); // 通过 trigger 任务触发 done
join

fork
    -> blast;
    wait ( blast.triggered );
join
```

示例中的第一个 fork 显示了两个事件标识符，done 和 done_too，引用相同的同步对象，以及如何将事件传递给触发事件的通用任务。在示例中，一个进程通过 done_too 等待事件，而实际触发是通过传递 done 作为参数的触发任务完成的。

在第二个 fork 中，一个进程可以在另一个进程（如果 `fork…join` 中的进程按源顺序执行）有机会执行之前触发事件 blast。尽管如此，第二个进程解除阻塞，fork 终止。这是因为进程等待事件的触发状态，该状态在整个时间步骤中保持触发状态。

### 15.5.4 事件顺序：`wait_order()`
`wait_order` 构造暂停调用进程，直到给定顺序（从左到右）触发所有指定事件，或者任何未触发的事件按顺序触发并因此导致操作失败。

`wait_order` 构造的语法如下 15-2：
---
```verilog
wait_statement ::= // from A.6.5
... 
| wait_order ( hierarchical_identifier { , hierarchical_identifier } ) action_block 
action_block ::= 
statement _or_null 
| [ statement ] else statement
```
---
语法 15-2—`wait_order` 事件顺序语法（摘自附录 A）

为了让 wait_order 成功，在序列中的任何一点，接下来的事件（在这一点应该都没有触发，或者序列已经失败了）应该按照指定的顺序触发。

前面的事件不限于只能发生一次。换句话说，一旦事件按照指定的顺序触发，它可以再次触发而不会导致构造失败。

只有在列表中的第一个事件可以等待持续 `triggered` 属性。

构造失败的操作取决于是否指定了可选的 `else` 语句块（失败语句）。如果指定了失败语句，则在构造失败时执行给定语句。如果未指定失败语句，则失败会生成运行时错误。

示例：
```verilog
wait_order( a, b, c );
```

暂停当前进程，直到事件 a、b 和 c 按照 a -> b -> c 的顺序触发。如果事件乱序，将生成运行时错误。

示例：
```verilog
wait_order( a, b, c ) else $display( "Error: events out of order" );
```

在此示例中，失败语句指定，在构造失败时显示用户消息，但不生成错误。

示例：
```verilog
bit success;
wait_order( a, b, c ) success = 1; else success = 0;
```

在此示例中，完成状态存储在变量 success 中，但不生成错误。

### 15.5.5 命名事件变量上的操作
事件是具有几个重要属性的唯一数据类型。命名事件可以相互分配。当一个事件分配给另一个事件时，源事件的同步队列由源事件和目标事件共享。从这个意义上说，事件充当全功能变量，而不仅仅是标签。

#### 15.5.5.1 合并事件
当一个事件变量分配给另一个事件变量时，两者合并。因此，在任一事件变量上执行 `->` 会影响等待任一事件变量的进程。

例如：
```verilog
event a, b, c;
a = b;
-> c;
-> a; // 也触发 b
-> b; // 也触发 a
a = c;
b = a;
-> a; // 也触发 b 和 c
-> b; // 也触发 a 和 c
-> c; // 也触发 a 和 b
```

当事件合并时，赋值仅影响后续事件控制或等待操作的执行。如果一个进程在等待 event1 时被阻塞，而另一个事件被赋值给 event1，那么当前等待进程永远不会解除阻塞。例如：
```verilog
fork
    T1: forever @ E2; 
    T2: forever @ E1;
    T3: begin
        E2 = E1;
        forever -> E2;
    end
join
```

此示例分叉了三个并发进程。每个进程同时开始。因此，在进程 T1 和 T2 阻塞时，进程 T3 将事件 E1 分配给 E2。结果，进程 T1 永远不会解除阻塞，因为事件 E2 现在是 E1。要解除线程 T1 和 T2 的阻塞，必须在分叉之前合并 E2 和 E1。

#### 15.5.5.2 回收事件
当事件变量分配特殊的 null 值时，事件变量与底层同步队列之间的关联被断开。当没有事件变量与底层同步队列关联时，队列本身的资源变为可重用。

触发 `null` 事件不会产生任何效果。等待 `null` 事件的结果是未定义的，实现可以发出运行时警告。

例如：
```verilog
event E1 = null;
@ E1; // 未定义：可能永远阻塞，也可能根本不阻塞
wait( E1.triggered ); // 未定义
-> E1; // 无效果
```

#### 15.5.5.3 事件比较
事件变量可以与其他事件变量或特殊值 null 进行比较。只允许使用以下运算符比较事件变量：
 - 与另一个事件或 null 的相等性（==）
 - 与另一个事件或 null 的不等性（!=）
 - 与另一个事件或 null 的 case 相等性（===）（与 == 相同的语义）
 - 与另一个事件或 null 的 case 不等性（!==）（与 != 相同的语义）
 - 测试布尔值，如果事件为 null 则为 0，否则为 1

示例：
```verilog
event E1, E2;
if ( E1 ) // 与 if ( E1 != null ) 相同
    E1 = E2;
if ( E1 == E2 )
    $display( "E1 and E2 are the same event" );
```
