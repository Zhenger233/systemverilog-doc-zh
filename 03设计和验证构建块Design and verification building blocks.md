# 3. 设计和验证构件

## 3.1 概述

本章描述了以下内容：

- 模块、程序、接口、检查器和原语的目的
- 子程序的概述
- 包的概述
- 配置的概述
- 设计层次结构的概述
- 编译和构建的定义
- 声明名称空间
- 仿真时间、时间单位和时间精度
  本章定义了几个重要的SystemVerilog术语和概念，这些术语和概念在本文档中被使用。该条款还概述了用于表示硬件设计及其验证环境的建模块的目的和用途。

## 3.2 设计元素

设计元素是 SystemVerilog 模块（参见第 23 章）、程序（参见第 24 章）、接口（参见第 25 章）、检查器（参见第 17 章）、包（参见第 26 章）、原语（参见第 28 章）或配置（见第 33 条）。这些结构由关键字引入，分别是 module, program, interface, checker, package, primitive 和 config。
设计元素是用于建模和构建设计和验证环境的主要构建块。 这些构建块是声明和过程代码的容器，在本文档的后续章节中讨论。
本章描述了这些构建块的用途。 有关这些语法和语义的完整详细信息在本标准的后面章节中定义。

## 3.3 模块

SystemVerilog 中的基本构建块是模块，包含在关键字 module 和 endmodule 之间。 模块主要用于表示设计块，但也可以用作验证代码和验证块与设计块之间互连的容器。模块可以包含的结构包括如下：
— 端口，有端口声明
— 数据声明，例如线网、变量、结构体和联合体
— 常量声明
— 用户定义的类型定义
— 类定义
— 从包中导入声明
— 子程序定义
— 其他模块、程序、接口、检查器和原语的实例化
— 类对象的实例化
— 连续赋值

— 程序块

— 生成块
— 指定块
列表中的每个结构将在本标准的后续章节中详细讨论。
注意——前面的列表并不包括所有内容。 模块可以包含额外的构造，这也在本标准的后续章节中讨论。
以下是表示 2 对 1 多路复用器的模块的简单示例：

```systemverilog
module mux2to1 (input wire a, b, sel, // combined port and type declaration
output logic y);
always_comb begin // procedural block
if (sel) y = a; // procedural statement
else y = b;
end
endmodule: mux2to1
```

模块在第 23 章中有更详细的介绍。另请参阅 3.11 中关于使用模块创建设计层次结构的内容。

## 3.4 程序

程序构建块包含在关键字 program...endprogram 之间。 这个结构用于建模测试平台环境。 模块结构适用于描述硬件。 然而对于测试台，重点不在硬件级细节上，例如连线，结构层次和互连，而是在对设计被验证的完整环境进行建模。
程序块服务于以下三个基本目的：
— 它提供了测试平台的执行入口。
— 它创建了一个范围来封装程序范围的数据、任务和函数。
— 它提供了一个语法上下文，用于指定 Reactive 区域中的调度。
程序结构是设计和测试台之间的明确分隔符，更重要的是，它指定专门的模拟执行语义。 连同时钟块（见第 14 条），
程序结构提供了设计和测试平台之间的无竞争交互，并支持周期事务级抽象。
程序块可以包含数据声明、类定义、子程序定义、对象实例，以及一项或多项初始或最终程序。 它不能包含 always 过程、原语实例、模块实例、接口实例或其他程序实例。
SystemVerilog 的抽象和建模结构简化了测试平台的创建和维护。 实例化和单独连接每个程序实例的能力使它们可以用作泛化模型。
示例程序声明如下：

```SystemVerilog
program test (input clk, input [16:1] addr, inout [7:0] data);
initial begin
...
endprogram
```

程序结构在第 24 章中详细讨论。

## 3.5 接口

接口构建块包含在关键字 interface...endinterface 之间，封装了设计块之间以及设计和验证块之间的通信，允许从抽象的系统级设计通过连续的细化平滑地迁移到较低级别的寄存器传输和设计的结构视图。通过封装块之间的通信，接口结构还有助于设计重用。
在最低级别，接口是命名的一组线网或变量。该接口在一个设计中被实例化并可以连接到其他模块、接口和程序实例的接口端口。一个接口可以通过一个端口作为一个单项来访问。
并在需要时引用组件网或变量。设计的很大一部分通常由端口列表和端口连接列表组成，这只是名字的重复。 用单个名称替换一组名称的能力可以显著减少描述的大小并提高其可维护性。
接口的额外功能来自于它封装功能和连接的能力，使接口在其最高级别更像类模板。接口可以有参数、常量、变量、函数和任务。接口中元素的类型可以被声明，或者类型可以作为参数传入。成员变量和函数是相对于接口的实例名称作为实例成员来引用的。因此，通过接口连接的模块可以简单地调用该接口的子程序成员来驱动通信。由于功能被封装在接口中并与模块隔离，通信协议的抽象水平和/或粒度可以很容易地通过用包含相同成员，但在不同的抽象层次上实现的另一个接口代替原有接口来改变。通过接口连接的模块根本不需要改变。

modport 结构为模块端口提供方向信息并控制子程序在特定模块内的使用。顾名思义，方向是指从模块中看到的方向。
除了子例程方法之外，接口还可以包含过程块（即 initial 过程或 always 过程）和连续赋值，这对系统级建模和测试平台应用程序很有用。 这允许接口包括它自己的协议检查器，自动验证所有通过接口连接的模块符合指定的协议。 其他应用程序，例如功能覆盖率记录和报告、协议检查和断言也可以内置到接口中。
一个接口定义和使用的简单例子如下：

```SystemVerilog
interface simple_bus(input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
endinterface: simple_bus
module memMod(simple_bus a); // simple_bus interface port
logic avail;
// When memMod is instantiated in module top, a.req is the req
// signal in the sb_intf instance of the 'simple_bus' interface
always @(posedge clk) a.gnt <= a.req & avail;
endmodule
module cpuMod(simple_bus b); // simple_bus interface port
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf(.clk(clk)); // Instantiate the interface
memMod mem(.a(sb_intf)); // Connect interface to module instance
cpuMod cpu(.b(sb_intf)); // Connect interface to module instance
endmodule
```

接口在第 25 章有完整描述。

## 3.6 检查器

checker 结构包含在关键字 checker...endchecker 中，代表一个封装了断言与建模代码的验证块。检查器的预期用途是作为用于创建形式验证中使用的抽象辅助模型的验证库单元或构建块。检查器结构在第 17 章中详细讨论。

## 3.7 原语

原始结构用于表示低级逻辑门和开关。 SystemVerilog 包括许多内置的原语类型。设计人员可以使用用户定义原语(UDP)来补充内置原语。UDP 包含在关键字 primitive...endprimitive 之间。 内置原语和 UDP 结构允许对时序精确的数字电路进行建模，通常称为门级建模。门级建模在第 28 章到第 31 章中进行了更全面的讨论。

## 3.8 子程序

⼦程序提供了⼀种机制来封装可从⼀个或多个位置调⽤的可执⾏代码。⼦程序有两种形式，任务（13.3）和函数（13.4）。

任务作为语句被调用。任务可以有任意数量的input、output、inout 和 ref 参数，但不返回值。任务可以在执⾏期间阻塞模拟时间。也就是说，任务退出可以发⽣在⽐任务被调⽤时更晚的模拟时间。

函数可以有返回值，也可以定义为不返回值的 void 函数。⾮空函数调⽤⽤作表达式中的操作数。 void 作为语句被调用。函数可以
有input、output、inout 和 ref 参数。函数必须在不阻塞模拟时间的情况下执⾏，但可以分离阻塞时间的程序。

## 3.9 包

模块、接⼝、程序和检查器为声明提供本地命名空间。在模块、接⼝、程序或检查器中声明的标识符在该范围内是局部的，不会影响或
与其他构建块中的声明冲突。

包提供了⼀个声明空间，可以被其他构建块共享。包声明可以导⼊到其他构建块中，包括其他包。

包在关键字package...endpackage 之间定义。例如：

```systemverilog
package ComplexPkg;
typedef struct {
shortreal i, r;
} Complex;
function Complex add(Complex a, b);
add.r = a.r + b.r;
add.i = a.i + b.i;
endfunction
function Complex mul(Complex a, b);
mul.r = (a.r * b.r) - (a.i * b.i);
mul.i = (a.r * b.i) + (a.i * b.r);
endfunction
endpackage : ComplexPkg
```

包的完整语法和语义在第 26 章中描述。

## 3.10 配置

SystemVerilog 提供指定设计配置的能⼒，它指定模块实例到特定 SystemVerilog 源代码的绑定信息。配置使⽤库。库是模块、接
⼝、程序、检查器、原语、包和其他配置的集合。单独的库映射⽂件指定库中包含的单元的源代码位置。库映射⽂件的名称通常指定为模拟器或读取 SystemVerilog 源代码的其他软件⼯具的调⽤选项。

关于配置的细节见第33章。

## 3.11 层级概览

模块、程序、接⼝、检查器和原语的基本构建块⽤于构建设计层次结构。层次结构是由⼀个构建块实例化另⼀个构建块创建的。当⼀个
模块包含另⼀个模块、接⼝、程序或检查器的实例时，将创建⼀个新的层次结构级别。通过层次结构级别的通信主要是通过连接到实
例化模块、接⼝、程序或检查器的端⼝。

以下是使⽤简单声明的两个模块声明的⽰例。模块顶部包含模块mux2to1的实例，创建具有两层层次结构的设计。

```systemverilog
module top; // module with no ports
logic in1, in2, select; // variable declarations
wire out1; // net declaration
mux2to1 m1 (.a(in1), .b(in2), .sel(select), .y(out1)); // module instance
endmodule: top
module mux2to1 (input wire a, b, sel, // combined port and type declaration
output logic y);
// netlist using built-in primitive instances
not g1 (sel_n, sel);
and g2 (a_s, a, sel_n);
and g3 (b_s, b, sel);
or g4 (y, a_s, b_s);
endmodule: mux2to1 
```

模块可以实例化其他模块、程序、接⼝、检查器和原语，从⽽创建层次结构树。接⼝还可以实例化其他构建块并创建层次结构树。程序和检查器可以实例化其他检查器。原语不能实例化其他构建块，它们是层次结构树中的叶⼦。

通常，经过详细说明但未显式实例化的模块或程序会在层次结构树的顶部隐式实例化⼀次，并成为顶级层次结构块（参⻅23.3和
24.3）。

SystemVerilog 允许多个顶层块。

任何层级中的标识符都可以使⽤层级路径名从任何其他层级引⽤（⻅23.6）。

实例化语法和设计层次结构在第 23 章中有更详细的介绍。

## 3.12 编译和细化

编译是读取 SystemVerilog 源代码、解密加密代码以及分析源代码的语法和语义错误的过程。实现可以在⼀个或多个过程中执⾏
编译。实现可以以专有的中间格式保存编译结果，或者可以将编译结果直接传递到细化阶段。并不是所有的语法和语义都可以在编译
过程中进⾏检查。有些检查只能在细化过程中或细化完成时进行。

SystemVerilog 通过使⽤编译单元⽀持单⽂件和多⽂件编译（参⻅3.12.1）。

细化是将构成设计的组件绑定在⼀起的过程。这些组件可以包括模块实例、程序实例、接⼝实例、检查器实例、原语实例和设计层次结
构的顶层。细化发⽣在解析源代码之后和模拟之前；它涉及扩展实例化、计算参数值、解析层次名称、建⽴⽹络连接以及通常的仿真设
计准备。有关细化过程的更多详细信息，参⻅23.10.4。

尽管本标准定义了编译和细化的结果，但编译和细化步骤不需要在实现中是不同的阶段。在本标准中，术语编译过程、编译动作和编译器通常指的是组合的编译和细化过程。因此，例如当标准提到“编译时错误”时，允许实现在仿真开始之前的任何时间报告错误。

本标准通常不规定有关设计元素编译顺序的要求。两个例外是关于“编译单元”的规则（⻅3.12.1） ，其中编译期间的实际⽂件边界
很重要，以及关于引⽤包项的规则（⻅26.3） ，其中包的编译需要先于引⽤它。

### 3.12.1 编译单元

SystemVerilog ⽀持使⽤编译单元进⾏单独编译。提供了以下术语和定义：

编译单元：⼀起编译的⼀个或多个 SystemVerilog 源⽂件的集合。

编译单元范围：编译单元的本地范围。它包含所有位于任何其他范围之外的声明。

$unit：⽤于在编译单元范围内显式访问标识符的名称。

定义哪些⽂件构成编译单元的确切机制是特定于⼯具的。但是，兼容⼯具应提供允许以下两种情况的使⽤。

a) 给定编译命令⾏上的所有⽂件组成⼀个编译单元（在这种情况下，这些⽂件中的声明可以按照整个⽂件集中的正常可⻅性规则访问）。
b) 每个⽂件都是⼀个单独的编译单元（在这种情况下，每个编译单元中的声明范围只能在其对应的⽂件中访问）。

使⽤⼀个或多个`include指令包含的⽂件内容成为包含它们的⽂件的编译单元的一部分。

如果⽂件末尾有不完整的声明，则包含该⽂件的编译单元将遍历每个后续⽂件，直到⽂件组末尾没有不完整声明。

还有其他可能的⽂件到编译单元的映射，定义它们的机制是特定于⼯具的，可能不可移植。

尽管编译单元作⽤域不是包，但它可以包含任何可以在包内定义的项（⻅26.2）和绑定结构（⻅23.11）。这些项在编译单元范
围命名空间中（⻅3.13）。

以下项在所有编译单元中都是可⻅的：模块、原语、程序、接⼝和包。在编译单元范围内定义的项不能从编译单元外部通过名称访
问。可以使⽤ PLI 访问编译单元范围内的项⽬，它必须提供⼀个迭代器来遍历所有编译单元。

编译单元范围内的项⽬可以具有对标识符的分层引⽤。对于向上的名称引⽤（⻅23.8），编译单元范围被视为顶层设计单元。这意味
着如果这些不是对在编译单元范围内创建的标识符的引⽤或通过将包导⼊编译单元范围⽽变得可⻅，则它们将被视为从设计顶部开
始的完整路径名（$root ，描述在23.3.1）。

在⼀个单独编译的单元中，编译器指令⼀旦被⼯具看到就适⽤于所有后续的源⽂本。但是，来⾃⼀个单独编译单元的编译器指令不
应影响其他编译单元。这可能会导致单独编译单元或作为包含整个源代码的单个编译单元之间的行为差异。

在范围内引⽤标识符时：

⾸先，搜索嵌套范围（参⻅23.9）（包括嵌套模块声明），包括通过包导⼊声明提供的任何标识符。

接下来，搜索在引⽤之前定义的编译单元范围部分（包括通过包导⼊声明提供的任何标识符）。

最后，如果标识符遵循层次名称解析规则，则搜索实例层次（⻅23.8和23.9）。

$unit是包含编译单元的范围的名称。其⽬的是允许明确引⽤编译单元最外层的声明（即编译单元范围内的声明）。这是通过⽤于访
问包项的相同范围解析运算符完成的（参⻅26.3）。

例如：

```systemverilog
bit b;
task t;
int b;
b = 5 + $unit::b; // $unit::b is the one outside
endtask
```

除了任务和函数名称（⻅23.8.1）之外，只能引⽤编译单元中已经定义的名称。显式$unit::前缀的使⽤仅提供名称消歧，并不增加引⽤
后续编译单元项的能力。

例如：

```systemverilog
task t;
int x;
x = 5 + b; // illegal - "b" is defined later
x = 5 + $unit::b; // illegal - $unit adds no special forward referencing
endtask
bit b;
```

编译单元范围允许⽤⼾轻松地跨编译单元共享声明（例如：类型），但不必声明随后从中导⼊声明的包。因为它没有名称，所以编译单
元作⽤域不能与导⼊声明⼀起使⽤，并且作⽤域内声明的标识符不能通过层次引⽤访问。然⽽，在特定的编译单元中，特殊名称$unit
可⽤于显式访问其编译单元范围内的声明。

## 3.13 命名空间

SystemVerilog 有⼋个标识符的命名空间：两个是全局的（定义命名空间和包命名空间），两个对编译单元是全局的（编译单元命
名空间和⽂本宏命名空间），四个是局部的。⼋个名称空间描述如下：

a)定义名称空间统⼀了在所有其他声明之外定义的所有⾮嵌套模块、原语、程序和接⼝标识符。⼀旦名称⽤于在⼀个编译单元内定义模块、原语、或接⼝，则不得再次使⽤该名称（在任何编译单元中）声明另⼀个⾮嵌套模块、原语、程序或接⼝其他声明。

b)包名称空间统⼀了所有编译单元中定义的所有包标识符。⼀旦名称被⽤于定义⼀个编译单元中的包，该名称不得再次⽤于声明任何编译单元中的另一个包。

c)编译单元作⽤域名称空间存在于模块、接⼝、包、检查器、程序和原始构造之外。它统⼀了编译单元范围内的函数、任务、检查器、参数、命名事件、⽹络声明、变量声明和⽤⼾定义类型的定义。

d)⽂本宏名称空间在编译单元内是全局的。因为⽂本宏名称被引⼊并与`前导字符⼀起使⽤，所以它们与任何其他名称空间保持
明确。⽂本宏名称是按照输⼊⽂件集中出现的线性顺序定义的组成编译单元。相同名称的后续定义将覆盖输⼊⽂件余额的先前定义。

e)模块名称空间由模块、接⼝、包、程序、检查器和原始结构引⼊。它统⼀了模块、接⼝、程序、检查器、函数、任务、命名块、实例名称、参数、命名事件、⽹络声明、变量声明和封闭结构中的⽤⼾定义类型的定义。

f)块名称空间由命名或未命名块、指定、函数和任务构造引⼊。它统⼀了封闭结构中命名块、函数、任务、参数、命名事件、变量声明类型和⽤⼾定义类型的定义。

g)端⼝名称空间由模块、接⼝、原语和程序构造引⼊。它提供了⼀种在结构上定义两个不同名称空间中的两个对象之间的连接的⽅
法。连接可以是单向的（input或output）或双向的（inout或ref）。端⼝名称空间与模块和块名称空间重叠。

本质上，端⼝名称空间指定了不同名称空间中的名称之间的连接类型。声明的端⼝类型包括input、 output、 inout和ref。在端⼝名称空间中引⼊的端⼝名称可以通过声明与端⼝名称同名的变量或⽹络在模块名称空间中重叠。

h)属性名称空间由附在语⾔元素上的（**和**）结构包围（⻅5.12）。属性名称只能在属性名称空间中定义和使⽤。不能在此名称空间
中定义任何其他类型的名称。

在名称空间内，重新声明已在先前声明中声明的名称是⾮法的。

## 3.14 仿真时间单位和精度

模拟的⼀个重要⽅⾯是时间。术语仿真时间⽤于指代仿真器维护的时间值，以模拟被仿真的系统描述所花费的实际时间。术语时间与
模拟时间可互换使用。

时间值在设计元素中⽤于表⽰传播延迟和过程语句执⾏之间的模拟时间量。时间值有两个组成部分，时间单位和时间精度。

时间单位表⽰时间和延迟的测量单位，可以指定单位从 100 秒单位到 1 ⻜秒单位不等。

时间精度指定延迟的准确程度。

时间单位和时间精度均使⽤以下字符串之⼀表⽰： s、 ms、 us、 ns、 ps和fs ，数量级分别为 1、10 或 100。这些字符串的定义如
下所示。

| 字符串 | 计量单位 |
| ------ | -------- |
| s      | 秒       |
| ms     | 毫秒     |
| us     | 微秒     |
| ns     | 纳秒     |
| ps     | 皮秒     |
| fs     | 飞秒     |

注 虽然 s、ms、ns、ps 和 fs 是秒、毫秒、纳秒、⽪秒和⻜秒的常⽤ SI 单位符号，但由于编码字符集中缺少希腊字⺟ (mu)，“us”代表微秒的 SI 单位符号μs。

设计元素的时间精度应⾄少与时间单位⼀样精确；它不能是⽐时间单位更⻓的时间单位。

3.14.1 时间值舍入

在模块、程序或接⼝等设计元素中，时间精度指定延迟值在⽤于仿真之前如何舍入。

时间精度是相对于时间单位的。如果精度与时间单位相同，则延迟值四舍五⼊为整数。如果精度⽐时间单位⼩⼀个数量级，则延迟值四舍五⼊到⼩数点后⼀位。例如，如果指定的时间单位为1ns ，精度为100ps，则延迟值四舍五⼊到⼩数点后⼀位（100ps相当于0.1ns）。因此， 2.75ns的延迟将四舍五⼊为2.8ns。

设计元素中的时间值精确到为该设计元素指定的时间精度单位，即使在设计的其他地⽅指定了更⼩的时间精度。

### 3.14.2 指定时间单位和精度

可以通过以下两种⽅式指定时间单位和精度：

使⽤编译器指令`timescale

使⽤关键字timeunit和timeprecision

#### 3.14.2.1 `timescale编译器指令

\`timescale编译器指令为所有遵循此指令且未在设计元素中指定timeunit和timeprecision构造的设计元素指定默认时间单位和精度。 \`timescale指令从在源代码中遇到它时一直有效，直到读取另一个\`timescale编译器指令。\`timescale指令只影响当前的编译单元；它不跨越多个编译单元（⻅3.12.1）。

\`timescale指令的⼀般语法是（有关更多详细信息，请参⻅22.7）：

```verilog
`timescale time_unit / time_precision
```

以下⽰例指定时间单位为 1 ns，精度为 10 ps（精确到⼩数点后2位）。

编译器指令影响模块A和B。第⼆个\`timescale指令替换第⼀个指令，为模块 C 指定 1 ps 的时间单位和 1 ps 的精度（精度为零小数位）。

```systemverilog
`timescale 1ns / 10ps
module A (...);
...
endmodule
module B (...);
...
endmodule
`timescale 1ps/1ps
module C (...);
...
endmodule
```

`timescale指令可能会导致⽂件顺序依赖性问题。如果上⾯的三个模块按照A、B、C的顺序编译（如图），那么模块B将以纳秒为单位进⾏模拟。如果同样的三个⽂件按C、B、A的顺序编译，那么模块将以⽪秒为单位进⾏模拟。这可能会导致⾮常不同的模拟结果，具体取决于模块B中指定的时间值。

#### 3.14.2.2 timeunit 和 timeprecision 关键字

时间单位和精度可以分别由timeunit和timeprecision关键字声明，并设置为时间字面量（⻅5.8）。时间精度也可以使⽤斜杠分隔符使⽤timeunit关键字的可选第⼆个参数来声明。例：

```systemverilog
module D (...);
timeunit 100ps;
timeprecision 10fs;
...
endmodule
module E (...);
timeunit 100ps / 10fs; // timeunit with optional second argument
...
endmodule
```

在设计元素中定义timeunit和timeprecision构造消除了编译器指令的⽂件顺序依赖性问题。

对于任何模块、程序、包或接⼝定义或在任何编译单元范围内，最多应有⼀个时间单位和⼀个时间精度。这将定义⼀个时间范围。如果指定，timeunit和timeprecision声明应在当前时间范围内的任何其他项之前。 timeunit和timeprecision声明可以作为后⾯的项⽬重复，但必须与当
前时间范围内的先前声明匹配。

#### 3.14.2.3 timeunit、timeprecision和\`timescale的优先级

如果在模块、程序、包或接⼝定义中未指定时间单位，则应使⽤以下优先规则确定时间单位：

a) 如果模块或接⼝定义是嵌套的，则时间单位应从封闭的模块或接⼝继承（程序和包不能嵌套）。

b) 否则，如果先前指定了\`timescale指令（在编译单元内），则时间单位应设置为最后⼀个\`timescale指令的单位。

c) 否则，如果编译单元范围指定了⼀个时间单元（在所有其他声明之外），则时间单位应设置为编译单元的时间单位。

d) 否则，应使⽤默认时间单位。

编译单元范围的时间单位只能由timeunit声明设置，⽽不是\`timescale指令。如果未指定，则应使⽤默认时间单位。

如果在当前时间范围内未指定时间精度，则时间精度应按照与时间单位相同的优先级来确定。

默认时间单位和精度是特定于实现的。

如果某些设计元素指定了时间单位和精度，⽽其他设计元素没有指定，则应为错误。

### 3.14.3 仿真时间单位

全局时间精度，也称为模拟时间单元，是所有时间精度语句、 timeunit声明的所有时间精度参数以及设计中所有\`timescale编译器
指令的最⼩时间精度参数的最⼩值。

步时间单位等于全局时间精度。与代表物理单位的其他时间单位不同，步⻓不能⽤于设置或修改精度或时间单位。
