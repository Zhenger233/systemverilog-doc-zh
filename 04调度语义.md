# 4. 调度语义

## 4.1 一般规定

本章描述以下内容：
 - 基于事件的仿真调度语义
 - systemverilog 的分层时间调度算法
 - 事件顺序的确定性和不确定性
 - 竞争条件的可能来源
 - PLI 回调控制点

## 4.2 硬件模型的执行及其验证环境

本标准剩余各章描述了语⾔各个元素的⾏为。本章概述了这些元素之间的相互作⽤，特别是关于事件的安排和执行。

组成 SystemVerilog 语⾔的元素可⽤于描述电⼦硬件的不同抽象层次的⾏为。SystemVerilog 是⼀种并⾏的编程语⾔。某些语⾔结构的执⾏由块或进程的并⾏执⾏定义。重要的是理解什么执⾏顺序可以保证给⽤⼾，什么执⾏顺序是不确定的。

尽管 SystemVerilog 不仅仅⽤于仿真，但该语⾔的语义是针对仿真，其他⼀切都是从这个基本定义中抽象出来的。

## 4.3 事件仿真

SystemVerilog 语言根据离散事件执行模型定义。本章将更详细地描述离散事件模拟，以便提供上下文来描述 SystemVerilog 结构的含义和有效解释。这些定义为仿真提供了标准的 SystemVerilog 参考算法，所有兼容的模拟器都应实现该参考算法。在下面的事件执行模型定义中，有很多选择，不同的模拟器在执行的一些细节上可能存在差异。此外，SystemVerilog 模拟器可以自由使用本条款中描述的不同算法，前提是用户可见的效果与参考算法一致。

一个SystemVerilog描述由连接的执行线程或进程组成。进程是可以计算的对象，可以有状态，可以对输入的变化作出响应，从而产生输出。进程是并发调度的元素，如 **initial** 过程。进程的例子包括但不限于原语；**initial、always、always_comb、always_latch** 和 **always_ff** 过程；连续赋值；异步任务；过程赋值语句。

在被模拟的系统描述中，线网或变量的状态的每一个变化都被认为是一个 *更新事件*。

进程对更新事件敏感。当执行更新事件时，对该事件敏感的所有进程都将考虑以任意顺序进行计算。过程的计算也是一个事件，称为 *计算事件*。

计算事件还包括 PLI 回调，它是执行模型中的点，可以从模拟内核调用 PLI 应用程序。

除了事件之外，模拟器的另一个关键方面是时间。术语 *仿真时间* 是指模拟器维护的时间值，用于模拟系统描述被模拟所需的实际时间。在本章中，术语 *时间* 与 *仿真时间* 可以互换使用。

为了完全支持清晰和可预测的交互，单个时隙被划分为多个区域，在这些区域中，事件可以被安排为特定类型的执行顺序。这允许属性和检查器在 DUT 处于稳定状态时采样数据。属性表达式可以安全地求值，测试平台可以以零延迟的方式对属性和检查器做出反应，所有这些都以一种可预测的方式进行。这种机制还允许设计、时钟传播和/或激励和响应代码中的非零延时自由地混合，并与周期精确描述一致。

## 4.4 分层事件调度器

一个合格的 SystemVerilog 模拟器应该维护某种形式的数据结构，允许事件被动态地调度、执行，并随着模拟器的时间推移而删除。该数据结构通常实现为一组按时间顺序排列的链表，以定义良好的方式进行划分和再划分。

第一种划分是时间划分。每个事件都有且只有一个模拟执行时间，在模拟过程中的任何给定时间点，可以是当前时间，也可以是未来的某个时间。所有在特定时间调度的事件定义一个时隙。模拟的过程是，按照时间顺序执行并删除当前模拟时隙中的所有事件，然后再移动到下一个非空时隙。这个过程可以保证模拟器永远不会回到过去。

一个时隙被划分为一组有序的区域，如下所示：
 1. Preponed
 2. Pre-Active 
 3. Active
 4. Inactive
 5. Pre-NBA
 6. NBA
 7. Post-NBA
 8. Pre-Observed 
 9. Observed
 10. Post-Observed 
 11. Reactive
 12. Re-Inactive 
 13. Pre-Re-NBA 
 14. Re-NBA
 15. Post-Re-NBA
 16. Pre-Postponed 
 17. Postponed

将时隙划分为这些有序区域的目的是在设计和测试代码之间提供可预测的交互。

注意：这些区域实际上包含了 IEEE 1364-2005 模拟参考模型，具有完全相同的确定性水平。换句话说，遗留的 Verilog 代码应该继续正确运行，而无需根据 SystemVerilog 机制修改。

### 4.4.1 Active 区域集合和 reactive 区域集合

有两组重要的事件区域用于帮助定义 SystemVerilog 活动的调度，即 active 区域集和 reactive 区域集。调度在 Active、Inactive、Pre-NBA、NBA 和 Post-NBA 区域中的事件为 *Active 区域集合* 事件。调度在 Reactive、Re-Inactive、Pre- Re-NBA、Re-NBA 和 Post-Re-NBA 区域中的事件是 *Reactive 区域集合* 事件。

Active、Inactive、Pre-NBA、NBA、Post-NBA、Pre-Observed、Observed、 Post- Observed、Reactive、Re-Inactive、Pre-Re-NBA、Re-NBA、Post-Re-NBA 和 Pre-Postponed 区域称为 *可迭代区域*。

每个时隙的所有事件区域除了分为 active 区域集和 reactive 区域集外，还可以分为 *仿真区域*（参见4.4.2）或 *PLI 区域*（参见4.4.3）。

### 4.4.2 仿真区域

一个时隙的仿真区域为 Preponed、Active、Inactive、NBA、Observed、Reactive、Re-Inactive、Re-NBA 和 Postponed。事件区域的执行流程如图 4-1 所示。

#### 4.4.2.1 Preponed 事件区域

`#1step` 采样延迟提供了在进入当前时隙之前立即采样数据的能力。`#1step` 采样等同于在当前时隙的 Preponed 区域中获取数据样本。在 Preponed 区域的采样与在前一个 Postponed 区域的采样是等价的。

Preoned 区域 PLI 事件也调度在该区域中（参见4.4.3.1）。

#### 4.4.4.2 Active 事件区域

Active 区域保存了当前被计算的 active 区域集事件，可以以任何顺序处理。

#### 4.4.2.3 Inactive 事件区域

Inactive 区域保存了在所有 active 事件处理完毕后要计算的事件。

如果事件在 active 区域集中执行，则显式的 `#0` 延迟控制要求暂停进程，并将事件调度到当前时间槽的 Inactive 区域，以便在下一次从 Inactive 到 Active 的迭代中恢复进程。

#### 4.4.2.4 NBA 事件区域
NBA (nonblocking assignment update，非阻塞赋值更新) 区域保存了所有 Inactive 事件处理完毕后要计算的事件。

如果事件在 active 区域集合中执行，则非阻塞赋值将在 NBA 区域中创建一个事件，调度在当前或以后的仿真时间进行。