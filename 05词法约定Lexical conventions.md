# 5. 词法约定
## 5.1 概述
本章描述以下内容：
 - 词法标记（空格、注释、操作符）
 - 整数、实数、字符串、数组、结构体和时间字面量
 - 内置方法调用
 - 属性

## 5.2 词法标记
SystemVerilog 源文本文件应该是词法标记流。*词法标记* 应该由一个或多个字符组成。标记在源文件中的布局应该是自由格式；也就是说，除了作为符号分隔符之外，空格和换行符在语法上没有任何意义，转义的标识符除外（参见5.6.1）。

语言中的词法标记类型如下:
 - 空白
 - 注释
 - 操作符
 - 数量
 - 字符串字面量
 - 标识符
 - 关键字

## 5.3 空白
空白应包含空格、制表符、换行符和换页符。这些字符应被忽略，除非它们用于分隔其他词法标记。但是，空格和制表符应被视为字符串字面量中的重要字符（见 5.9）。

## 5.4 注释
SystemVerilog 有两种引入注释的形式。*单行注释* 应该以两个字符 `//` 开始，以换行符结束。块注释应该以 `/*` 开始，以 `*/` 结束。块注释不能嵌套。单行注释标记 `//` 在块注释中没有任何特殊含义。

## 5.5 操作符
操作符是单字符、双字符或三字符序列，用于表达式中。11 章讨论表达式中操作符的使用。

*一元运算符* 应该出现在其操作数的左侧。*二元运算符* 应该出现在操作数之间。*条件运算符* 应该用两个运算符字符分隔三个操作数。

## 5.6 标识符、关键字和系统名称
*标识符* 用于为对象提供唯一的名称，以便对其进行引用。标识符可以是简单标识符，也可以是转义的标识符（参见 5.6.1）。一个 *简单标识符* 应该是任何字母、数字、美元符号（`$`）和下划线字符（`_`）的序列。

简单标识符的第一个字符不能是数字或 `$`，它可以是一个字母或下划线。标识符应区分大小写。

例如:
 - shiftreg_a
 - busa_index
 - error_condition
 - merge_ab
 - _bus3
 - `n$657`

实现可以对标识符的最大长度设置限制，但限制应至少为 1024 个字符。如果标识符超过特定于实现的长度限制，则应报告错误。

### 5.6.1 转义的标识符
*转义标识符* 应以反斜杠字符（`\`）开始，以空格（空格、制表符、换行符）结束。它们提供了一种方法，可以在标识符中包含任何可打印的 ASCII 字符（十进制值 33 ~ 126，或十六进制的 21 ~ 7E ）。

开头的反斜杠字符和结束的空格都不被认为是标识符的一部分。因此，转义标识符 `\cpu3` 与非转义标识符 cpu3 被视为相同。

例如:
 - `\busa+index`
 - `\-clock`
 - `***error-condition***`
 - `\net1/\net2`
 - `\{a,b}`
 - `\a*(b+c)`

### 5.6.2 关键字
*关键字* 是预定义的非转义标识符，用于定义语言结构。前面有转义字符的 SystemVerilog 关键字不会被解释为关键字。

所有关键字都只能用小写形式定义。附录 B 列出了所有定义的关键字。第 22.14 小节讨论了保留关键字与 IEEE Std 1364 和 IEEE Std 1800 以前版本的兼容性。

### 5.6.3 系统任务和系统函数
美元符号（`$`）引入了一种语言结构，允许开发用户定义的系统任务和系统函数。系统构件不是设计语义，而是指仿真器功能。`$` 后面的名称被解释为系统任务或系统函数。

语法 5-1 给出了系统任务和系统函数的语法。

---
```
system_tf_call ::= // from A.8.2
    system_tf_identifier [ ( list_of_arguments ) ] 
    | system_tf_identifier ( data_type [ , expression ] )
system_tf_identifier ::= $[ a-zA-Z0-9_$ ]{ [ a-zA-Z0-9_$ ] } // from A.9.3
// $ 字符在 system_tf_identifier 中不能跟空格。system_tf_identifier 不能转义。
```
---
语法 5-1——系统任务和系统函数的语法（摘自附录 A）

SystemVerilog 在本文档中定义了一套标准的系统任务和系统函数（参见第 20 章和第 21 章）。如第 36 章所述，可以使用 PLI 定义其他 *用户定义的系统任务和系统函数*。软件实现还可以指定额外的系统任务和系统函数，这些任务和功能可能是特定于工具的（有关一些常见的额外系统任务和系统函数，请参见附录 D）。额外的系统任务和系统函数不属于本标准。

例如:
```verilog
$display(“显示一条消息”);
$finish;
```

### 5.6.4 编译器指令
`` ` ``字符（ASCII 值为 0x60，称为 *重音符号*)引入了一种用于实现编译器指令的语言结构。由编译器指令指示的编译器行为应该在编译器读取指令时立即生效。该指令将在编译的其余部分保持有效，除非另一个编译器指令另有规定。因此，一个描述文件中的编译器指令可以控制多个描述文件中的编译行为。编译器指令的效果仅限于一个编译单元（见 3.12.1），不影响其他编译单元。

例如:
```verilog
`define wordsize
```

SystemVerilog 在本文档中定义了一组标准的编译器指令（参见第 22 章）。软件实现还可以指定额外的编译器指令，这些指令可能是特定于工具的（有关一些常见的额外编译器指令，请参见附件 E）。额外的编译器指令不是这个标准的一部分。

## 5.7 数字
*常数* 可以指定为整型常量（参见 5.7.1）或实数常量（参见5.7.2）。数字的形式语法见语法5-2。

---
```
primary_literal ::= number | time_literal | unbased_unsized_literal | string_literal // from A.8.4
time_literal ::= 
unsigned_number time_unit 
| fixed_point_number time_unit
time_unit ::= s | ms | us | ns | ps | fs
number ::= // from A.8.7
integral_number 
| real_number 
integral_number ::= 
decimal_number 
| octal_number 
| binary_number 
| hex_number 
decimal_number ::= 
unsigned_number 
| [ size ] decimal_base unsigned_number 
| [ size ] decimal_base x_digit { _ } 
| [ size ] decimal_base z_digit { _ } 
binary_number ::= [ size ] binary_base binary_value 
octal_number ::= [ size ] octal_base octal_value 
hex_number ::= [ size ] hex_base hex_value 
sign ::= + | -
size ::= non_zero_unsigned_number 
non_zero_unsigned_number ::= non_zero_decimal_digit { _ | decimal_digit} 
real_number ::= 
fixed_point_number 
| unsigned_number [ . unsigned_number ] exp [ sign ] unsigned_number 
fixed_point_number ::= unsigned_number . unsigned_number 
exp ::= e | E
unsigned_number ::= decimal_digit { _ | decimal_digit } 
binary_value ::= binary_digit { _ | binary_digit } 
octal_value ::= octal_digit { _ | octal_digit } 
hex_value ::= hex_digit { _ | hex_digit } 
decimal_base ::= '[s|S]d | '[s|S]D
binary_base ::= '[s|S]b | '[s|S]B
octal_base ::= '[s|S]o | '[s|S]O
hex_base ::= '[s|S]h | '[s|S]H
non_zero_decimal_digit ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
decimal_digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
binary_digit ::= x_digit | z_digit | 0 | 1
octal_digit ::= x_digit | z_digit | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
hex_digit ::= x_digit | z_digit | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f | A | B | C | D | E | F
x_digit ::= x | X
z_digit ::= z | Z | ?
unbased_unsized_literal ::= '0 | '1 | 'z_or_x
string_literal ::= " { Any_ASCII_Characters } " // from A.8.8
// 嵌入空格是非法的
// 时间字面量中的无符号数字或定点数字后面不能跟空格
// unbased_unsized_literal 中的撇号（'）后面不能有空格
```
---
语法 5-2——整数和实数的语法（摘自附录 A）

### 5.7.1 整数字面量常量
*整数字面量常量* 可以指定为十进制、十六进制、八进制或二进制格式。

有两种形式表示整数字面量常量。第一种形式是一个简单的十进制数，它应该被指定为一个数字 0 到 9 的序列，可以选择以加号或减号一元运算符开始。第二种形式指定了一个 *基数字面量常量*，它最多由三个标记组成：一个可选的大小常量、一个撇号字符（`'`，ASCII 0x27），后跟一个基本格式字符，以及表示该数字值的数字。用宏替代这三个标记是合法的。

第一个标记是一个大小常量，它应该根据整数字面量常量的精确位数指定其大小。它应该被指定为一个非零的无符号十进制数。例如，两个十六进制数字的大小规格是 8，因为一个十六进制数字需要 4 位。

第二个标记，*基数格式*，应该由一个不区分大小写的字母组成，指定数字的基数，可选的是前面有单个字符 `s`（或 `S`）来表示有符号的数量，前面有撇号字符。对于十进制、十六进制、八进制和二进制，合法的基数规范分别是`d`、`D`、`h`、`H`、`o`、`O`、`b` 或 `B`。

撇号字符和基本格式字符之间不得有任何空格分隔。

第三个标记是一个无符号数，应该由指定的基本格式合法的数字组成。无符号数字标记应紧跟着基本格式，可选在前面加空格。十六进制数字 `a` 到 `f` 不区分大小写。

没有大小和基本格式的简单十进制数应被视为 *有符号整数*，而使用基本格式指定的数字应被视为有符号整数（如果包含 `s` 指示符）或 *无符号整数*（如果只使用基本格式）。`s` 指示符不影响指定的位模式，只影响其解释。

在大小常量之前的加减运算符是一元加减运算符。在基本格式和数字之间使用加号或减号操作符是非法语法。

*负数* 应以二进制补码形式表示。

`x` 表示以十六进制、八进制和二进制字面量常量表示的 *未知值*。`z` 为 *高阻抗值*。有关SystemVerilog 数值集合的讨论请参见 6.3。`x` 应该在十六进制中设置 4 位为未知，在八进制中设置 3 位为未知，在二进制中设置 1 位为未知。同样，`z` 应分别设置 4 位、 3 位、1 位为高阻抗值。

如果无符号数的大小小于字面常量指定的大小，则无符号数应该用零填充到左侧。如果无符号数的最左侧位是 `x` 或 `z`，则分别向左填充 `x` 或 `z`。如果无符号数的大小大于字面常量指定的大小，则应从左侧截断无符号数。

组成无大小数（简单的十进制数或有基本说明但没有大小说明的数）的位数至少为 32。高位未知的无大小无符号字面常量（`X` 或 `x`）或三态（`Z` 或 `z`）应扩展到包含该文字常量的表达式的大小。

注意：在 IEEE Std 1364-1995 中，在大小不定的字面常量中，高位是未知或三态，`x` 或 `z` 只扩展到32位。

可以通过在单个位值之前使用撇号（`'`）来指定未设置大小的单个位值，但不使用基数说明符。未设置大小的值的所有位都应设置为指定位的值。在一个自确定的上下文中，一个未设置大小的单比特值的宽度应为1位，并且该值应被视为无符号。
```verilog
    '0, '1, 'X, 'x, 'Z, 'x // 将所有位设置为指定值
```

在定义数值时使用 `x` 和 `z` 是不区分大小写的。

在用于数字时，问号（`?`）字符是 SystemVerilog 中 `z` 字符的替代。它设置 4 位十六进制高阻抗值，3 位八进制高阻抗值，1 位二进制高阻抗值。在高阻抗值是不关心条件的情况下，问号可以用来增强可读性。参见 12.5.1 节对 `casez` 和 `casex` 的讨论。问号字符也用于 UDP 状态表。参见 29.3.6 中的表 29-1。

在十进制字面量常量中，无符号数字标记不应包含任何 `x`、`z`或 `?` 字符，除非标记中只有一个数字，表示十进制字面量常数中的每一位都是 `x` 或 `z`。

下划线字符（`_`）在数字中的任何位置都是合法的，第一个字符除外。下划线字符被忽略。为了可读性的目的，这个特性可以用来断开长数字。

下面是几个指定整数字面量的例子。

示例1：大小不定的字面常量
```verilog
659      // 是一个小数
'h 837FF // 是一个十六进制数
'o7460   // 是一个八进制数
4af      // 不合法（十六进制格式需要 'h）
```
示例2：设置大小的字面常量
```verilog
4'b1001 // 是 4 位二进制数
5 'D 3  // 是 5 位十进制数
3'b01x  // 最小有效位未知的 3 位数字
12'hx   // 是一个 12 位的未知数
16'hz   // 是 16 位高阻抗数
```
示例3：使用符号的字面常量
```verilog
8 'd -6  // 这种语法是非法的
-8 'd 6  // 这定义了 6 的二进制补码，保持在8位，相当于-（8'd 6）
4 'shf   // 表示 4 位数字 '1111'，被解释为二进制补码，或 '-1'。它等于 -4'h 1
-4 'sd15 // 等价于 -(-4'd 1) 或 '0001'
16'sd?   // 和 16'sbz 一样
```
示例4：常量数值的自动左填充
```verilog
logic [11:0] a, b, c, d; 
logic [84:0] e, f, g; 
initial begin
    a = 'h x;   // 生成 xxx
    b = 'h 3x;  // 生成 03x 
    c = 'h z3;  // 生成 zz3 
    d = 'h 0z3; // 生成 0z3 
    e = 'h5;    // 生成 {82{1'b0},3'b101} 
    f = 'hx;    // 生成 {85{1'hx}} 
    g = 'hz;    // 生成 {85{1'hz}}
end
```
示例5：使用单个位值自动填充常量字面量数字
```verilog
logic[15:0] a, b, c, d;
A = '0; // 将所有 16 位设置为 0
B = '1; // 将所有 16 位设置为 1
C = 'x; // 将所有 16 位设置为 x
D = 'z; // 将所有 16 位设置为 z
```
示例6：文本常量中的下划线
```verilog
27_195_000              // 无大小十进制 27195000
16'b0011_0101_0001_1111 // 16 位二进制数
32 'h 12ab_f001         // 32 位十六进制数
```
有大小的负的常数和有大小有符号的常数在赋值给类型为 logic 的数据对象时都具有符号扩展功能，而不管该类型本身是否有符号。

`x` 和 `z` 的默认长度与整数的默认长度相同。

### 5.7.2 实数常量
*实数字面量常量* 按照 IEEE Std 754 双精度浮点数标准描述的方式表示。

实数既可以用十进制记数法（如 14.72）指定，也可以用科学记数法（如 39e8，表示 39 乘以 10 的 8 次方）指定。用小数点表示的实数，小数点两边至少有一位。

例如:
```verilog
1.2
0.1
2394.26331
1.2E12（指数符号可以是 e 或 E）
1.30e-2
0.1e-0
23E10
29E-2
236.123_763_e-12（下划线被忽略）
```
下面这些是无效的实数形式，因为它们的小数点两边都不至少有一位数字：
```verilog
.12
9.
4.E3
.2e-7
```
定点格式（如 1.2）和指数格式（如 2.0e10）的默认类型应该是 `real`。

转换可用于将字面量实数转换为 `shortreal` 类型（例如，`shortreal'(1.2)`）。转换在 6.24 中描述。

实数转换为整数时，应将实数舍入为最接近的整数，而不是将其截断。将实数赋值给整数时，发生隐式转换。.5 舍入时应远离 0。例如:
 - 实数 35.7 和 35.5 转换成整数后都变成 36，而 35.2 变成 35。
 - 将 -1.5 转换为整数得到 -2，将 1.5 转换为整数得到2。

## 5.8 时间字面量
时间可以用整数或定点格式表示，后面跟着不带空格的时间单位（`fs ps ns us ms s`）。
例如:
```verilog
2.1ns
40ps
```
时间字面量被解释为缩放到当前时间单位并四舍五入到当前时间精度的 `realtime` 值。

## 5.9 字符串字面量
*字符串字面量* 是由双引号（`""`）括起来的字符序列。

非打印字符和其他特殊字符之前有一个反斜杠。

字符串字面量应该包含在单行中，除非新行前面紧跟一个 `\`（反斜杠）。在这种情况下，反斜杠和换行符会被忽略。字符串字面量的长度没有预定义的限制。

示例1:
```verilog
$display(“矮胖子坐在墙上。\
胖墩儿摔了一跤。”);
```
打印
`胖墩儿坐在墙上。胖墩儿摔了一跤。`

示例2:
```verilog
$display("胖墩儿坐在墙上。\n\
胖墩儿摔了一跤。”)；
```
打印
```
胖墩儿坐在墙上。
胖墩儿摔了一跤。
```
在表达式和赋值语句中用作操作数的字符串字面量应被视为由 8 位 ASCII 值序列表示的无符号整数常量，其中一个 8 位 ASCII 值表示一个字符。

字符串字面值可以赋值给整型，例如打包数组。如果大小不同，则向右对齐。为了完全存储字符串字面值，整型宽度应该声明为等于字符串中的字符数乘以 8。例如:
```verilog
byte c1 = "A";
Bit [7:0] d = "\n";
```
如果打包数组的宽度与字符数乘以 8 不匹配，则应遵循 SystemVerilog 赋值规则。当整型大于所分配的字符串文本值所需的值时，该值将右对齐，最左边的位用零填充，与非字符串值一样。如果字符串字面值大于目标整型，则对字符串进行右对齐，并截断最左边的字符。

例如，要存储 12 个字符的字符串 “Hello world\n”，需要一个 8 × 12 或 96 位宽的变量。
`bit [8*12:1] stringvar = "Hello world\n";`

或者，可以使用多维打包数组，带有 8 位子字段，如下所示：
`bit [0:11] [7:0] stringvar = "Hello world\n";`

字符串字面值可以分配给未打包的字节数组。如果大小不同，则左对齐。
`byte c3 [0:12] = "hello world\n";`

打包和未打包数组将在 7.4 中讨论。

字符串字面值也可以被强制转换为打包或未打包的数组类型，这将遵循与将字符串字面值赋给打包或未打包的数组相同的规则。强制类型转换将在 6.24 中讨论。

SystemVerilog 还包括一个 `string` 数据类型，可以为其分配字符串字面量。`string` 类型的变量具有任意长度；它们会动态调整大小以容纳任何字符串。字符串字面值是打包数组（宽度为 8 位的倍数），当赋值给字符串类型或用于包含字符串类型操作数的表达式时，它们会隐式转换为 `string` 类型（参见 6.16）。

存储在 vector 中的字符串字面值可以使用 SystemVerilog 操作符进行操作。操作符操作的值是 8 位 ASCII 值的序列。字符串字面量上的操作请参见 11.10。

### 5.9.1 字符串中的特殊字符
某些字符只有在前面有一个称为 *转义字符* 的介绍性字符时才能用于字符串字面值。表 5-1 列出了右列中的这些字符，其中的转义序列表示左列中的字符。

表 5-1——字符串字面量中的特殊字符
| 转义字符串 | 转义字符串产生的字符 |
| --- | --- |
| `\n` | 换行符 |
| `\t` | 制表符 |
| `\\` | 反斜杠符号 |
| `\"` | 双引号 |
| `\v` | 垂直制表符 |
| `\f` | 换页符 |
| `\a` | 响铃符 |
| `\ddd` | 用 1 到 3 个八进制数字指定的字符（参见语法 5-2）。如果使用少于三个字符的字符，则后面的字符不能是八进制数字。如果表示的字符大于 `\377`，则实现可能发出错误。转义序列中的八进制数字包含 x 或 z（参见语法 5-2）是违法的。|
| `\xdd` |  1 到 2 个十六进制数字指定的字符（参见语法 5-2）。如果只使用一个数字，则后面的字符不能是十六进制数字。转义序列中的十六进制数字包含 x 或 z（参见语法 5-2）是违法的。 |

## 5.10 结构字面量
结构字面量是带有常量成员表达式的结构赋值模式或模式表达式（见 10.9.2）。结构字面值必须具有类型，该类型可以通过前缀显式指示，也可以通过类似赋值的上下文隐式指示（参见 10.8）。
```verilog
    struct {int a; shortreal b;} ab；
    ab c;
    c = '{0, 0.0}；//从左上下文确定结构文字类型 (c)
```

嵌套的大括号应反映结构。例如:
`ab abarr[1:0] = '{'{1, 1.0}, '{2, 2.0}};`

前面示例中不允许使用类似 C 的替代选项 `'{1, 1.0, 2, 2.0}`。

结构字面值也可以使用成员名和值，或者使用数据类型和默认值（见 10.9.2）：
```verilog
    c = '{a:0, b:0.0}; //该成员的名称和值
    c = '{default: 0}; //结构 c 的所有元素都被设置为 0
    d = ab'{int:1, shortreal:1.0}；//该类型所有成员的数据类型和默认值
```

初始化结构数组时，嵌套的大括号应反映数组和结构。例如:
`ab abarr[1:0] = '{'{1, 1.0}, '{2, 2.0}};`

复制操作符可用于为成员的确切数量设置值。复制的内花括号被去除。
```verilog
struct {int X, Y, Z;} XYZ = '{3{1}};
typedef struct {int a, b[4];} ab_t;
int a, b, c;
ab_t v1[1:0] [2:0];
v1 = '{2{'{3{'{a,'{2{b,c}}}}}}};
/* 展开为 '{ '{3{ '{ a, '{2{ b, c }} } }}，
            '{3{ '{ a, '{2{ b, c }} } }}
          } */
/* 展开为 '{ '{ '{ a, '{2{ b, c }} },
               '{ a, '{2{ b, c }} },
               '{ a, '{2{ b, c }} }
             },
            '{ '{ a, '{2{ b, c }} },
               '{ a, '{2{ b, c }} },
               '{ a, '{2{ b, c }} }
             }
          } */
/* 展开为 '{ '{ '{ a, '{ b, c, b, c } },
               '{ a, '{ b, c, b, c } },
               '{ a, '{ b, c, b, c } }
             },
            '{ '{ a, '{ b, c, b, c } },
               '{ a, '{ b, c, b, c } },
               '{ a, '{ b, c, b, c } }
             }
          } */
```

## 5.11 数组字面量
数组字面量在语法上类似于 C 初始化器，但允许使用复制操作符（`{{}}`）。
`int n[1:2][1:3] = '{'{0,1,2},'{3 {4}}};`

与 C 语言不同，大括号的嵌套应该跟在维数后面。然而，复制操作符可以嵌套。复制的内花括号被去除。复制表达式只能在一个维度内操作。
`int n[1:2][1:6] = '{2{'{3{4,5}}}}; // 与 '{'{4,5,4,5,4,5},'{4,5,4,5,4,5}} 一样`

数组字面量是带有常量成员表达式的数组赋值模式或模式表达式（见 10.9.1）。数组字面量必须有一个类型，该类型可以用前缀显式地指示，也可以由类似赋值的上下文隐式地指示（见 10.8）。
```verilog
typedef int triple [1:3];
$mydisplay(triple'{0, 1, 2});
```

数组字面量也可以使用其索引或类型作为键并使用默认键值（参见 10.9.1）。
`triple b = '{1:1, default: 0}; // 索引 2 和 3 赋值 0`

## 5.12 属性
一种机制被包含，用于指定 SystemVerilog 源中的对象、语句和语句组的属性，这些属性可由各种工具（包括仿真器）使用，以控制工具的操作或行为。这些属性（property）被称为 *属性（attribute）*。这一节指定了用于指定属性的语法机制，没有对任何特定的属性进行标准化。

指定属性的语法请参见语法5-3。

---
```
attribute_instance ::= (* attr_spec { , attr_spec } *) // from A.9.1
attr_spec ::= attr_name [ = constant_expression ] 
attr_name ::= identifier
```
---
语法 5-3——属性语法

attribute_instance 可以作为附加在声明、模块项、语句或端口连接上的前缀出现在 SystemVerilog 描述中。它可以作为运算符的后缀出现，也可以作为表达式中的函数名出现。

没有值的属性的默认类型是 `bit`，值为 1。否则，属性采用表达式的类型。

如果为同一语言元素多次定义相同的属性名，则最后一个属性值应被使用，工具可以发出警告，指出出现了重复的属性。

不允许属性实例嵌套。使用包含属性实例的常量表达式指定属性值是非法的。

有关在特定语言元素上指定属性实例的语法，请参阅附录A。下面说明了几个例子。
例1：下面的例子展示了如何给 case 语句附加属性：
```verilog
(* full_case, parallel_case *)
case (a)
< rest_of_case_statement >
```
或
```verilog
(* full_case=1 *)
(* parallel_case=1 *) //多个属性实例也可以
case (a)
< rest_of_case_statement >
```
或
```verilog
(* full_case, //不赋值
parallel_case = 1 *)
case (a)
< rest_of_case_statement >
```
示例2：附加 full_case 属性，但不附加 parallel_case 属性：
```verilog
(* full_case *) //未指定parallel_case
case (a)
< rest_of_case_statement >
```
或
```verilog
(* full_case=1, parallel_case = 0 *)
case (a)
< rest_of_case_statement >
```

示例3：将属性附加到模块定义：
```verilog
(* optimize_power *)
module mod1 (<port_list>);
```
或
```verilog
(* optimize_power=1 *)
module mod1 (<port_list>);
```
示例4：将属性附加到模块实例化：
```verilog
(* optimize_power=0 *)
Mod1 synth1 (<port_list>);
```
例5：将属性附加到变量声明中：
```verilog
(* fsm_state *) logic [7:0] state1;
(* fsm_state=1 *) logic [3:0] state2, state3;
logic [3:0] reg1; // reg1 没有 fsm_state 设置
(* fsm_state=0 *) logic [3:0] reg2;// reg2 也没有
```
例6：给操作符附加一个属性：
`a = b + (* mode = "cla" *) c; // 将属性模式的值设置为字符串 cla。`

例7：给函数调用附加一个属性：
`a = add (* mode = "cla" *) (b, c);`
例8：给条件操作符附加一个属性：
`a = b ? (* no_glitch *) c : d;`

## 5.13 内置方法
SystemVerilog 使用类似 C++ 的类方法调用语法，其中使用点号（`.`）调用子进程：
`object.task_or_function()`

对象唯一标识子进程所操作的数据。因此，方法概念自然地被扩展到内置类型，以便添加功能，这在传统上是通过系统任务或系统功能完成的。与系统任务不同，内置方法没有 `$` 前缀，因为它们不需要特殊的前缀来避免与用户定义的标识符冲突。因此，方法语法允许扩展语言，而不需要添加新的关键字或使用系统任务扰乱全局名称空间。

与系统任务不同，内置方法不能由用户通过 PLI 任务重新定义。因此，只有不允许用户重新定义的函数才是内置方法调用的好候选函数。

通常，当特定功能应用于所有数据类型或应用于特定数据类型时，内置方法优于系统任务。例如:
`dynamic_array.size, associative_array.num, and string.len`

这些都是相似的概念，但它们代表不同的东西。动态数组具有大小，关联数组包含给定数量的项，字符串具有给定长度。使用相同的系统任务（例如 `$size`）来处理所有这些任务就不那么清晰和直观了。

内置方法只能与特定的数据类型相关联。因此，如果某些功能只是一个简单的副作用（例如 `$stop` 或 `$reset` ），或者它没有对特定的数据进行操作（例如 `$random`），那么必须使用系统任务。

当子程序内置方法调用没有指定参数时，子程序名称后面的空括号 `()` 是可选的。当所有参数都指定了默认值时，对于需要参数的子进程也是如此。对于方法，该规则允许简单的调用显示为对象或内置类型的属性。13.5.5 中为子进程定义了类似的规则。