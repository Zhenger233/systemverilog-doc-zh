# 5. 词法约定
## 5.1 概述
本章描述以下内容：
 - 词法标记（空格、注释、操作符）
 - 整数、实数、字符串、数组、结构体和时间字面量
 - 内置方法调用
 - 属性

## 5.2 词法标记
SystemVerilog 源文本文件应该是词法标记流。*词法标记* 应该由一个或多个字符组成。标记在源文件中的布局应该是自由格式；也就是说，除了作为符号分隔符之外，空格和换行符在语法上没有任何意义，转义的标识符除外（参见5.6.1）。

语言中的词法标记类型如下:
 - 空白
 - 注释
 - 操作符
 - 数量
 - 字符串字面量
 - 标识符
 - 关键字

## 5.3 空白
空白应包含空格、制表符、换行符和换页符。这些字符应被忽略，除非它们用于分隔其他词法标记。但是，空格和制表符应被视为字符串字面量中的重要字符（见 5.9）。

## 5.4 注释
SystemVerilog 有两种引入注释的形式。*单行注释* 应该以两个字符 `//` 开始，以换行符结束。块注释应该以 `/*` 开始，以 `*/` 结束。块注释不能嵌套。单行注释标记 `//` 在块注释中没有任何特殊含义。

## 5.5 操作符
操作符是单字符、双字符或三字符序列，用于表达式中。11 章讨论表达式中操作符的使用。

*一元运算符* 应该出现在其操作数的左侧。*二元运算符* 应该出现在操作数之间。*条件运算符* 应该用两个运算符字符分隔三个操作数。

## 5.6 标识符、关键字和系统名称
*标识符* 用于为对象提供唯一的名称，以便对其进行引用。标识符可以是简单标识符，也可以是转义的标识符（参见 5.6.1）。一个 *简单标识符* 应该是任何字母、数字、美元符号（`$`）和下划线字符（`_`）的序列。

简单标识符的第一个字符不能是数字或 `$`，它可以是一个字母或下划线。标识符应区分大小写。

例如:
 - shiftreg_a
 - busa_index
 - error_condition
 - merge_ab
 - _bus3
 - `n$657`

实现可以对标识符的最大长度设置限制，但限制应至少为 1024 个字符。如果标识符超过特定于实现的长度限制，则应报告错误。

### 5.6.1 转义的标识符
*转义标识符* 应以反斜杠字符（`\`）开始，以空格（空格、制表符、换行符）结束。它们提供了一种方法，可以在标识符中包含任何可打印的 ASCII 字符（十进制值 33 ~ 126，或十六进制的 21 ~ 7E ）。

开头的反斜杠字符和结束的空格都不被认为是标识符的一部分。因此，转义标识符 `\cpu3` 与非转义标识符 cpu3 被视为相同。

例如:
 - `\busa+index`
 - `\-clock`
 - `***error-condition***`
 - `\net1/\net2`
 - `\{a,b}`
 - `\a*(b+c)`

### 5.6.2 关键字
*关键字* 是预定义的非转义标识符，用于定义语言结构。前面有转义字符的 SystemVerilog 关键字不会被解释为关键字。

所有关键字都只能用小写形式定义。附录 B 列出了所有定义的关键字。第 22.14 小节讨论了保留关键字与 IEEE Std 1364 和 IEEE Std 1800 以前版本的兼容性。

### 5.6.3 系统任务和系统函数
美元符号（`$`）引入了一种语言结构，允许开发用户定义的系统任务和系统函数。系统构件不是设计语义，而是指仿真器功能。`$` 后面的名称被解释为系统任务或系统函数。

语法 5-1 给出了系统任务和系统函数的语法。

---
```
system_tf_call ::= // from A.8.2
    system_tf_identifier [ ( list_of_arguments ) ] 
    | system_tf_identifier ( data_type [ , expression ] )
system_tf_identifier ::= $[ a-zA-Z0-9_$ ]{ [ a-zA-Z0-9_$ ] } // from A.9.3
// $ 字符在 system_tf_identifier 中不能跟空格。system_tf_identifier 不能转义。
```
---
语法 5-1——系统任务和系统函数的语法（摘自附录 A）

SystemVerilog 在本文档中定义了一套标准的系统任务和系统函数（参见第 20 章和第 21 章）。如第 36 章所述，可以使用 PLI 定义其他 *用户定义的系统任务和系统函数*。软件实现还可以指定额外的系统任务和系统函数，这些任务和功能可能是特定于工具的（有关一些常见的额外系统任务和系统函数，请参见附录 D）。额外的系统任务和系统函数不属于本标准。

例如:
```verilog
$display(“显示一条消息”);
$finish;
```

### 5.6.4 编译器指令
`` ` ``字符（ASCII 值为 0x60，称为 *重音符号*）引入了一种用于实现编译器指令的语言结构。由编译器指令指示的编译器行为应该在编译器读取指令时立即生效。该指令将在编译的其余部分保持有效，除非另一个编译器指令另有规定。因此，一个描述文件中的编译器指令可以控制多个描述文件中的编译行为。编译器指令的效果仅限于一个编译单元（见 3.12.1），不影响其他编译单元。

例如:
```verilog
`define wordsize
```

SystemVerilog 在本文档中定义了一组标准的编译器指令（参见第 22 章）。软件实现还可以指定额外的编译器指令，这些指令可能是特定于工具的（有关一些常见的额外编译器指令，请参见附件 E）。额外的编译器指令不是这个标准的一部分。

## 5.7 数字
*常数* 可以指定为整型常量（参见 5.7.1）或实数常量（参见5.7.2）。数字的形式语法见语法5-2。

---
```
primary_literal ::= number | time_literal | unbased_unsized_literal | string_literal // from A.8.4
time_literal ::= 
unsigned_number time_unit 
| fixed_point_number time_unit
time_unit ::= s | ms | us | ns | ps | fs
number ::= // from A.8.7
integral_number 
| real_number 
integral_number ::= 
decimal_number 
| octal_number 
| binary_number 
| hex_number 
decimal_number ::= 
unsigned_number 
| [ size ] decimal_base unsigned_number 
| [ size ] decimal_base x_digit { _ } 
| [ size ] decimal_base z_digit { _ } 
binary_number ::= [ size ] binary_base binary_value 
octal_number ::= [ size ] octal_base octal_value 
hex_number ::= [ size ] hex_base hex_value 
sign ::= + | -
size ::= non_zero_unsigned_number 
non_zero_unsigned_number ::= non_zero_decimal_digit { _ | decimal_digit} 
real_number ::= 
fixed_point_number 
| unsigned_number [ . unsigned_number ] exp [ sign ] unsigned_number 
fixed_point_number ::= unsigned_number . unsigned_number 
exp ::= e | E
unsigned_number ::= decimal_digit { _ | decimal_digit } 
binary_value ::= binary_digit { _ | binary_digit } 
octal_value ::= octal_digit { _ | octal_digit } 
hex_value ::= hex_digit { _ | hex_digit } 
decimal_base ::= '[s|S]d | '[s|S]D
binary_base ::= '[s|S]b | '[s|S]B
octal_base ::= '[s|S]o | '[s|S]O
hex_base ::= '[s|S]h | '[s|S]H
non_zero_decimal_digit ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
decimal_digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
binary_digit ::= x_digit | z_digit | 0 | 1
octal_digit ::= x_digit | z_digit | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
hex_digit ::= x_digit | z_digit | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | a | b | c | d | e | f | A | B | C | D | E | F
x_digit ::= x | X
z_digit ::= z | Z | ?
unbased_unsized_literal ::= '0 | '1 | 'z_or_x
string_literal ::= " { Any_ASCII_Characters } " // from A.8.8
// 嵌入空格是非法的
// 时间字面量中的无符号数字或定点数字后面不能跟空格
// unbased_unsized_literal 中的撇号（'）后面不能有空格
```
---
语法 5-2——整数和实数的语法（摘自附录 A）

### 5.7.1 整数字面量常量
*整数字面量常量* 可以指定为十进制、十六进制、八进制或二进制格式。

有两种形式表示整数字面量常量。第一种形式是一个简单的十进制数，它应该被指定为一个数字 0 到 9 的序列，可以选择以加号或减号一元运算符开始。第二种形式指定了一个 *基数字面量常量*，它最多由三个标记组成：一个可选的大小常量、一个撇号字符（`'`，ASCII 0x27），后跟一个基本格式字符，以及表示该数字值的数字。用宏替代这三个标记是合法的。

第一个标记是一个大小常量，它应该根据整数字面量常量的精确位数指定其大小。它应该被指定为一个非零的无符号十进制数。例如，两个十六进制数字的大小规格是 8，因为一个十六进制数字需要 4 位。

第二个标记，*基数格式*，应该由一个不区分大小写的字母组成，指定数字的基数，可选的是前面有单个字符 `s`（或 `S`）来表示有符号的数量，前面有撇号字符。对于十进制、十六进制、八进制和二进制，合法的基数规范分别是`d`、`D`、`h`、`H`、`o`、`O`、`b` 或 `B`。

撇号字符和基本格式字符之间不得有任何空格分隔。

第三个标记是一个无符号数，应该由指定的基本格式合法的数字组成。无符号数字标记应紧跟着基本格式，可选在前面加空格。十六进制数字 `a` 到 `f` 不区分大小写。

没有大小和基本格式的简单十进制数应被视为 *有符号整数*，而使用基本格式指定的数字应被视为有符号整数（如果包含 `s` 指示符）或 *无符号整数*（如果只使用基本格式）。`s` 指示符不影响指定的位模式，只影响其解释。

在大小常量之前的加减运算符是一元加减运算符。在基本格式和数字之间使用加号或减号操作符是非法语法。

*负数* 应以二进制补码形式表示。

`x` 表示以十六进制、八进制和二进制字面量常量表示的 *未知值*。`z` 为 *高阻抗值*。有关SystemVerilog 数值集合的讨论请参见 6.3。`x` 应该在十六进制中设置 4 位为未知，在八进制中设置 3 位为未知，在二进制中设置 1 位为未知。同样，`z` 应分别设置 4 位、 3 位、1 位为高阻抗值。

如果无符号数的大小小于字面常量指定的大小，则无符号数应该用零填充到左侧。如果无符号数的最左侧位是 `x` 或 `z`，则分别向左填充 `x` 或 `z`。如果无符号数的大小大于字面常量指定的大小，则应从左侧截断无符号数。

组成无大小数（简单的十进制数或有基本说明但没有大小说明的数）的位数至少为 32。高位未知的无大小无符号字面常量（`X` 或 `x`）或三态（`Z` 或 `z`）应扩展到包含该文字常量的表达式的大小。

注意：在 IEEE Std 1364-1995 中，在大小不定的字面常量中，高位是未知或三态，`x` 或 `z` 只扩展到32位。

可以通过在单个位值之前使用撇号（`'`）来指定未设置大小的单个位值，但不使用基数说明符。未设置大小的值的所有位都应设置为指定位的值。在一个自确定的上下文中，一个未设置大小的单比特值的宽度应为1位，并且该值应被视为无符号。
```verilog
    '0, '1, 'X, 'x, 'Z, 'x // 将所有位设置为指定值
```

在定义数值时使用 `x` 和 `z` 是不区分大小写的。

在用于数字时，问号（`?`）字符是 SystemVerilog 中 `z` 字符的替代。它设置 4 位十六进制高阻抗值，3 位八进制高阻抗值，1 位二进制高阻抗值。在高阻抗值是不关心条件的情况下，问号可以用来增强可读性。参见 12.5.1 节对 `casez` 和 `casex` 的讨论。问号字符也用于 UDP 状态表。参见 29.3.6 中的表 29-1。

在十进制字面量常量中，无符号数字标记不应包含任何 `x`、`z`或 `?` 字符，除非标记中只有一个数字，表示十进制字面量常数中的每一位都是 `x` 或 `z`。

下划线字符（`_`）在数字中的任何位置都是合法的，第一个字符除外。下划线字符被忽略。为了可读性的目的，这个特性可以用来断开长数字。

下面是几个指定整数字面量的例子。

示例1：大小不定的字面常量
```verilog
659      // 是一个小数
'h 837FF // 是一个十六进制数
'o7460   // 是一个八进制数
4af      // 不合法（十六进制格式需要 'h）
```
示例2：设置大小的字面常量
```verilog
4'b1001 // 是 4 位二进制数
5 'D 3  // 是 5 位十进制数
3'b01x  // 最小有效位未知的 3 位数字
12'hx   // 是一个 12 位的未知数
16'hz   // 是 16 位高阻抗数
```
示例3：使用符号的字面常量
```verilog
8 'd -6  // 这种语法是非法的
-8 'd 6  // 这定义了 6 的二进制补码，保持在8位，相当于-（8'd 6）
4 'shf   // 表示 4 位数字 '1111'，被解释为二进制补码，或 '-1'。它等于 -4'h 1
-4 'sd15 // 等价于 -(-4'd 1) 或 '0001'
16'sd?   // 和 16'sbz 一样
```
示例4：常量数值的自动左填充
```verilog
logic [11:0] a, b, c, d; 
logic [84:0] e, f, g; 
initial begin
    a = 'h x;   // 生成 xxx
    b = 'h 3x;  // 生成 03x 
    c = 'h z3;  // 生成 zz3 
    d = 'h 0z3; // 生成 0z3 
    e = 'h5;    // 生成 {82{1'b0},3'b101} 
    f = 'hx;    // 生成 {85{1'hx}} 
    g = 'hz;    // 生成 {85{1'hz}}
end
```
示例5：使用单个位值自动填充常量字面量数字
```verilog
logic[15:0] a, b, c, d;
A = '0; // 将所有 16 位设置为 0
B = '1; // 将所有 16 位设置为 1
C = 'x; // 将所有 16 位设置为 x
D = 'z; // 将所有 16 位设置为 z
```
示例6：文本常量中的下划线
```verilog
27_195_000              // 无大小十进制 27195000
16'b0011_0101_0001_1111 // 16 位二进制数
32 'h 12ab_f001         // 32 位十六进制数
```
有大小的负的常数和有大小有符号的常数在赋值给类型为 logic 的数据对象时都具有符号扩展功能，而不管该类型本身是否有符号。

`x` 和 `z` 的默认长度与整数的默认长度相同。

### 5.7.2 实数常量
*实数字面量常量* 按照 IEEE Std 754 双精度浮点数标准描述的方式表示。

实数既可以用十进制记数法（如 14.72）指定，也可以用科学记数法（如 39e8，表示 39 乘以 10 的 8 次方）指定。用小数点表示的实数，小数点两边至少有一位。

例如:
```verilog
1.2
0.1
2394.26331
1.2E12（指数符号可以是 e 或 E）
1.30e-2
0.1e-0
23E10
29E-2
236.123_763_e-12（下划线被忽略）
```
下面这些是无效的实数形式，因为它们的小数点两边都不至少有一位数字：
```verilog
.12
9.
4.E3
.2e-7
```
定点格式（如 1.2）和指数格式（如 2.0e10）的默认类型应该是 `real`。

转换可用于将字面量实数转换为 `shortreal` 类型（例如，`shortreal'(1.2)`）。转换在 6.24 中描述。

实数转换为整数时，应将实数舍入为最接近的整数，而不是将其截断。将实数赋值给整数时，发生隐式转换。.5 舍入时应远离 0。例如:
 - 实数 35.7 和 35.5 转换成整数后都变成 36，而 35.2 变成 35。
 - 将 -1.5 转换为整数得到 -2，将 1.5 转换为整数得到2。

## 5.8 时间字面量
时间可以用整数或定点格式表示，后面跟着不带空格的时间单位（`fs ps ns us ms s`）。
例如:
```verilog
2.1ns
40ps
```
时间字面量被解释为缩放到当前时间单位并四舍五入到当前时间精度的 `realtime` 值。

## 5.9 字符串字面量
*字符串字面量* 是由双引号（`""`）括起来的字符序列。

非打印字符和其他特殊字符之前有一个反斜杠。

字符串字面量应该包含在单行中，除非新行前面紧跟一个 `\`（反斜杠）。在这种情况下，反斜杠和换行符会被忽略。字符串字面量的长度没有预定义的限制。

示例1:
```verilog
$display(“矮胖子坐在墙上。\
胖墩儿摔了一跤。”);
```
打印
`胖墩儿坐在墙上。胖墩儿摔了一跤。`

示例2:
```verilog
$display("胖墩儿坐在墙上。\n\
胖墩儿摔了一跤。”)；
```
打印
```
胖墩儿坐在墙上。
胖墩儿摔了一跤。
```
在表达式和赋值语句中用作操作数的字符串字面量应被视为由 8 位 ASCII 值序列表示的无符号整数常量，其中一个 8 位 ASCII 值表示一个字符。