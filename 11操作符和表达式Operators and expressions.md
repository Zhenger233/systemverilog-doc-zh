# 11. 操作符和表达式
## 11.1 概述
本章描述以下内容：
 - 表达式语义
 - 表达式上的操作
 - 操作符优先级
 - 操作数大小扩展规则
 - 有符号和无符号操作规则
 - 位和部分选择操作和最长静态前缀
 - 位流操作
 - 操作符重载

## 11.2 总览
本章描述了 SystemVerilog 中可用的操作符和操作数，以及如何使用它们来形成表达式。

*表达式* 是一种结构，它将 *操作数* 与 *操作符* 结合起来，以产生一个结果，该结果是操作数的值和操作符的语义含义的函数。任何合法的操作数，例如一个没有任何操作符的线网位选择，都被认为是一个表达式。在 SystemVerilog 语句中需要一个值的地方，可以使用表达式。

*操作数* 可以是以下之一：
 - 常量字面量，包括实数字面量
 - 字符串字面量
 - 参数，包括本地参数和 specify 参数
 - 参数位选择或部分选择，包括本地参数和 specify 参数
 - 线网（见 6.7）
 - 线网位选择或部分选择
 - 变量（见 6.8）
 - 变量位选择或部分选择
 - 结构，打包或未打包
 - 结构成员
 - 打包结构位选择或部分选择
 - 联合，打包、未打包或标记
 - 联合成员
 - 打包联合位选择或部分选择
 - 数组，打包或未打包
 - 打包数组位选择、部分选择、元素或切片
 - 未打包数组元素位选择或部分选择、元素或切片
 - 调用用户定义的函数、系统定义的函数或返回上述任何内容的方法

### 11.2.1 常量表达式
某些语句结构要求表达式是一个 *常量表达式*。常量表达式的操作数包括常量数字、字符串、参数、参数的常量位选择和部分选择、*常量函数调用*（见 13.4.3）以及仅限于 *常量系统函数调用*。常量表达式可以使用表 11-1 中定义的任何操作符。

*常量系统函数调用* 是对某些内置系统函数的调用，其中参数满足本节中概述的条件。在常量表达式中使用这些函数调用时，这些函数调用将在实例化时计算。可以在常量系统函数调用中使用的系统函数是 *纯函数*，即其值仅取决于其输入参数，没有副作用。

特定的内置系统函数，其中参数是常量表达式，是常量系统函数调用。具体来说，这些是列在 20.5 中的转换系统函数、列在 20.8 中的数学系统函数和列在 20.9 中的位向量系统函数。

列在 20.6 中的数据查询系统函数和列在 20.7 中的数组查询系统函数通常也是常量系统函数调用，即使它们的参数不是常量。请参阅这些章节，了解这些查询系统函数调用何时被视为常量表达式。

### 11.2.2 聚合表达式
未打包结构和数组数据对象，以及未打包结构和数组构造函数，都可以用作聚合表达式。未打包数组的多元素切片也可以用作聚合表达式。

聚合表达式可以在赋值、通过端口或作为子例程的参数中复制。聚合表达式也可以使用等式或不等式运算符进行比较。

如果比较运算符的两个操作数是聚合表达式，则它们应该是等价类型，如 6.22.2 中定义的那样。聚合表达式的赋值兼容性在 6.22.3 中定义，对于数组，在 7.6 中定义。

## 11.3 操作符
SystemVerilog 操作符的符号与 C 编程语言中的符号类似。语法 11-1 和表 11-1 列出了这些操作符。
---
```verilog
assignment_operator ::= // from A.6.2
= | += | -= | *= | /= | %= | &= | |= | ^= | <<= | >>= | <<<= | >>>=
conditional_expression ::= // from A.8.3
cond_predicate ? { attribute_instance } expression : expression 
unary_operator ::= // from A.8.6
+ | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~
binary_operator ::= 
+ | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **
| < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<
| -> | <-> 
inc_or_dec_operator ::= ++ | --
stream_operator ::= >> | << // from A.8.1
```
---
语法 11-1—操作符语法（摘自附录 A）

表 11-1—操作符和数据类型
| 操作符标记 | 名称 | 操作数数据类型 |
| :---: | :---: | :---: |
| `=` | 二进制赋值操作符 | 任意 |
| `+= -= /= *=` | 二进制算术赋值操作符 | 整数、实数、短实数 |
| `%=` | 二进制算术模数赋值操作符 | 整数 |
| `&= \|= ^=` | 二进制位赋值操作符 | 整数 |
| `>>= <<=` | 二进制逻辑移位赋值操作符 | 整数 |
| `>>>= <<<=` | 二进制算术移位赋值操作符 | 整数 |
| `?:` | 条件操作符 | 任意 |
| `+ -` | 一元算术操作符 | 整数、实数、短实数 |
| `!` | 一元逻辑否定操作符 | 整数、实数、短实数 |
| `~ & ~& \| ~\| ^ ~^ ^~` | 一元逻辑约减操作符 | 整数 |
| `+ - * / **` | 二进制算术操作符 | 整数、实数、短实数 |
| `%` | 二进制算术模数操作符 | 整数 |
| `& \| ^ ^~ ~^` | 二进制位操作符 | 整数 |
| `>> <<` | 二进制逻辑移位操作符 | 整数 |
| `>>> <<<` | 二进制算术移位操作符 | 整数 |
| `&& \|\| –> <–>` | 二进制逻辑操作符 | 整数、实数、短实数 |
| `< <= > >=` | 二进制关系操作符 | 整数、实数、短实数 |
| `=== !==` | 二进制 case 相等操作符 | 除实数和短实数外的任何 |
| `== !=` | 二进制逻辑相等操作符 | 任意 |
| `==? !=?` | 二进制通配符相等操作符 | 整数 |
| `++ --` | 一元增量、减量操作符 | 整数、实数、短实数 |
| `inside` | 二进制集合成员操作符 | 左操作数的单数 |
| `dist` | 二进制分布操作符 | 整数 |
| `{} {{}}` | 连接、复制操作符 | 整数 |
| `{<<{}} {>>{}}` | 流操作符 | 整数 |

dist 操作符在 16.14.2 和 18.5.4 中描述。

### 11.3.1 具有实数操作数的操作符
表 11-1 显示了可以应用于实数操作数的操作符。

使用逻辑或关系操作符或 inside 操作符对实数操作数的结果应为单比特标量值。

对于其他操作符，如果任何操作数（条件操作符中的问号之前的除外）是 real，则结果为 real。否则，如果任何操作数（条件操作符中的问号之前的除外）是 shortreal，则结果为 shortreal。

实数操作数还可以用于以下表达式：
 - `str.realval // 结构或联合成员`
 - `realarray[intval] // 数组元素`

有关使用实数的更多信息，请参见 6.12.1。

### 11.3.2 操作符优先级
操作符优先级和结合性列在表 11-2 中。最高优先级首先列出。

表 11-2——操作符优先级和结合性
| 操作符 | 结合性 | 优先级 |
| :---: | :---: | :---: |
| `() [] :: .` | 左 | 最高 |
| `+ - ! ~ & ~& \| ~\| ^ ~^ ^~ ++ --（一元）` |  |  |
| `**` | 左 | |
| `* / %` | 左 | |
| `+ -（二进制）` | 左 | |
| `<< >> <<< >>>` | 左 | |
| `< <= > >= inside dist` | 左 | |
| `== != === !== ==? !=?` | 左 | |
| `&（二进制）` | 左 | |
| `^ ~^ ^~（二进制）` | 左 | |
| `\|（二进制）` | 左 | |
| `&&` | 左 | |
| `\|\|` | 左 | |
| `?:（条件操作符）` | 右 | |
| `–> <–>` | 右 | |
| `= += -= *= /= %= &= ^= \|= <<= >>= <<<= >>>= := :/ <=` | 无 |  |
| `{} {{}}` | 连接 | 最低 |

表 11-2 中显示的操作符应具有相同的优先级。行按操作符的优先级降序排列。例如，`* /` 和 `%` 的优先级相同，高于二进制 `+` 和 `-` 操作符的优先级。

所有操作符应该从左到右关联，除了条件（?:）、蕴含（->）和等价（<->）操作符，它们应该从右到左关联。关联性指的是具有相同优先级的操作符的计算顺序。因此，在以下示例中，B 被添加到 A，然后从 A+B 的结果中减去 C。
```verilog
A + B - C
```

当操作符的优先级不同时，具有更高优先级的操作符应首先关联。在以下示例中，B 被除以 C（除法的优先级高于加法），然后将结果添加到 A。
```verilog
A + B / C
```

可以使用括号更改操作符优先级。
```verilog
(A + B) / C // 与 A + B / C 不同
```

### 11.3.3 在表达式中使用整数字面量
整数字面量可以用作表达式中的操作数。整数字面量可以表示为以下内容：
 - 未定型、未基数的整数（例如，12）
 - 未定型、基数整数（例如，'d12，'sd12）
 - 有大小、基数整数（例如，16'd12，16'sd12）

有关整数字面量语法，请参见 5.7.1。

对于没有基数说明符的整数的负值，应该与具有基数说明符的整数有所不同。没有基数说明符的整数应该被解释为二进制补码形式的有符号值。具有无符号基数说明符的整数应该被解释为无符号值。

以下示例显示了写表达式“减 12 除以 3”的四种方法。请注意，-12 和 -'d12 都计算为相同的二进制补码位模式，但在表达式中，-'d12 失去了作为有符号负数的身份。
```verilog
int IntA;
IntA = -12 / 3; // 结果是 -4
IntA = -'d 12 / 3; // 结果是 1431655761
IntA = -'sd 12 / 3; // 结果是 -4
IntA = -4'sd 12 / 3; // -4'sd12 是 4 位数量 1100 的负值，即 -4。-(-4) = 4
// 结果是 1
```

### 11.3.4 对逻辑（4 状态）和位（2 状态）类型的操作
操作符可以应用于 2 状态值或混合 2 状态和 4 状态值。结果与将所有值视为 4 状态值时相同。在大多数情况下，如果所有操作数都是 2 状态，则结果在 2 状态值集中。唯一的例外是产生 x 结果的操作符，对于 2 状态值集中的操作数（例如，除以零）。
```verilog
int n = 8, zero = 0;
int res = 'b01xz | n; // res 得到 'b11xz 强制转换为 int，或 'b1100
int sum = n + n; // sum 得到 16 强制转换为 int，或 16
int sumx = 'x + n; // sumx 得到 'x 强制转换为 int，或 0
int div2 = n/zero + n; // div2 得到 'x 强制转换为 int，或 0
integer div4 = n/zero + n; // div4 得到 'x
```

### 11.3.5 操作符表达式短路
在评估表达式时，操作符应遵循结合性规则，如 11.3.2 中所述。某些操作符（&&、||、-> 和 ?:）应使用短路评估；换句话说，如果不需要它们的值来确定操作的最终值，则它们的某些操作数表达式将不被评估。每个操作符的详细短路行为在其相应的子句中描述（11.4.7 和 11.4.11）。所有其他操作符不应使用短路评估——它们的所有操作数表达式总是被评估。当发生短路时，由于评估短路操作数表达式而导致的任何副作用或运行时错误都不会发生。

例如：
```verilog
logic regA, regB, regC, result ;

function logic myFunc(logic x);
    ...
endfunction

result = regA & (regB | myFunc(regC)) ;
```

即使 regA 已知为零，子表达式 (regB | myFunc(regC)) 将被评估，并且由于调用 myFunc(regC) 而引起的任何副作用都将发生。

请注意，实现可以通过省略子表达式的评估来进行优化，只要模拟行为（包括副作用）就像遵循标准规则一样。

### 11.3.6 表达式中的赋值
表达式可以包括一个阻塞赋值，前提是它没有定时控制。这些阻塞赋值应该用括号括起来，以避免常见错误，例如使用 a=b 代替 a==b 或使用 a|=b 代替 a!=b。
```verilog
if ((a=b)) b = (a+=1);
a = (b = (c = 5));
```

这种赋值表达式的语义是一个函数，它评估右侧，将右侧强制转换为左侧数据类型，将其堆叠，更新左侧，然后返回堆叠的值。返回的值的数据类型是左侧的数据类型。如果左侧是一个连接，则返回的值的数据类型应该是一个无符号整数数据类型，其位长度是其操作数的长度之和。

在事件表达式、过程连续赋值内的表达式或不在过程语句内的表达式中包含赋值运算符是非法的。





