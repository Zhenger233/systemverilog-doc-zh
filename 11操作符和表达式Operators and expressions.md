# 11. 操作符和表达式
## 11.1 概述
本章描述以下内容：
 - 表达式语义
 - 表达式上的操作
 - 操作符优先级
 - 操作数大小扩展规则
 - 有符号和无符号操作规则
 - 位和部分选择操作和最长静态前缀
 - 位流操作
 - 操作符重载

## 11.2 总览
本章描述了 SystemVerilog 中可用的操作符和操作数，以及如何使用它们来形成表达式。

*表达式* 是一种结构，它将 *操作数* 与 *操作符* 结合起来，以产生一个结果，该结果是操作数的值和操作符的语义含义的函数。任何合法的操作数，例如一个没有任何操作符的线网位选择，都被认为是一个表达式。在 SystemVerilog 语句中需要一个值的地方，可以使用表达式。

*操作数* 可以是以下之一：
 - 常量字面量，包括实数字面量
 - 字符串字面量
 - 参数，包括本地参数和 specify 参数
 - 参数位选择或部分选择，包括本地参数和 specify 参数
 - 线网（见 6.7）
 - 线网位选择或部分选择
 - 变量（见 6.8）
 - 变量位选择或部分选择
 - 结构，打包或未打包
 - 结构成员
 - 打包结构位选择或部分选择
 - 联合，打包、未打包或标记
 - 联合成员
 - 打包联合位选择或部分选择
 - 数组，打包或未打包
 - 打包数组位选择、部分选择、元素或切片
 - 未打包数组元素位选择或部分选择、元素或切片
 - 调用用户定义的函数、系统定义的函数或返回上述任何内容的方法

### 11.2.1 常量表达式
某些语句结构要求表达式是一个 *常量表达式*。常量表达式的操作数包括常量数字、字符串、参数、参数的常量位选择和部分选择、*常量函数调用*（见 13.4.3）以及仅限于 *常量系统函数调用*。常量表达式可以使用表 11-1 中定义的任何操作符。

*常量系统函数调用* 是对某些内置系统函数的调用，其中参数满足本节中概述的条件。在常量表达式中使用这些函数调用时，这些函数调用将在实例化时计算。可以在常量系统函数调用中使用的系统函数是 *纯函数*，即其值仅取决于其输入参数，没有副作用。

特定的内置系统函数，其中参数是常量表达式，是常量系统函数调用。具体来说，这些是列在 20.5 中的转换系统函数、列在 20.8 中的数学系统函数和列在 20.9 中的位向量系统函数。

列在 20.6 中的数据查询系统函数和列在 20.7 中的数组查询系统函数通常也是常量系统函数调用，即使它们的参数不是常量。请参阅这些章节，了解这些查询系统函数调用何时被视为常量表达式。

### 11.2.2 聚合表达式
未打包结构和数组数据对象，以及未打包结构和数组构造函数，都可以用作聚合表达式。未打包数组的多元素切片也可以用作聚合表达式。

聚合表达式可以在赋值、通过端口或作为子例程的参数中复制。聚合表达式也可以使用等式或不等式运算符进行比较。

如果比较运算符的两个操作数是聚合表达式，则它们应该是等价类型，如 6.22.2 中定义的那样。聚合表达式的赋值兼容性在 6.22.3 中定义，对于数组，在 7.6 中定义。

## 11.3 操作符
SystemVerilog 操作符的符号与 C 编程语言中的符号类似。语法 11-1 和表 11-1 列出了这些操作符。
---
```verilog
assignment_operator ::= // from A.6.2
= | += | -= | *= | /= | %= | &= | |= | ^= | <<= | >>= | <<<= | >>>=
conditional_expression ::= // from A.8.3
cond_predicate ? { attribute_instance } expression : expression 
unary_operator ::= // from A.8.6
+ | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~
binary_operator ::= 
+ | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **
| < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<
| -> | <-> 
inc_or_dec_operator ::= ++ | --
stream_operator ::= >> | << // from A.8.1
```
---
语法 11-1—操作符语法（摘自附录 A）

表 11-1—操作符和数据类型
| 操作符标记 | 名称 | 操作数数据类型 |
| :---: | :---: | :---: |
| `=` | 二进制赋值操作符 | 任意 |
| `+= -= /= *=` | 二进制算术赋值操作符 | 整数、实数、短实数 |
| `%=` | 二进制算术模数赋值操作符 | 整数 |
| `&= \|= ^=` | 二进制位赋值操作符 | 整数 |
| `>>= <<=` | 二进制逻辑移位赋值操作符 | 整数 |
| `>>>= <<<=` | 二进制算术移位赋值操作符 | 整数 |
| `?:` | 条件操作符 | 任意 |
| `+ -` | 一元算术操作符 | 整数、实数、短实数 |
| `!` | 一元逻辑否定操作符 | 整数、实数、短实数 |
| `~ & ~& \| ~\| ^ ~^ ^~` | 一元逻辑约减操作符 | 整数 |
| `+ - * / **` | 二进制算术操作符 | 整数、实数、短实数 |
| `%` | 二进制算术模数操作符 | 整数 |
| `& \| ^ ^~ ~^` | 二进制位操作符 | 整数 |
| `>> <<` | 二进制逻辑移位操作符 | 整数 |
| `>>> <<<` | 二进制算术移位操作符 | 整数 |
| `&& \|\| –> <–>` | 二进制逻辑操作符 | 整数、实数、短实数 |
| `< <= > >=` | 二进制关系操作符 | 整数、实数、短实数 |
| `=== !==` | 二进制 case 相等操作符 | 除实数和短实数外的任何 |
| `== !=` | 二进制逻辑相等操作符 | 任意 |
| `==? !=?` | 二进制通配符相等操作符 | 整数 |
| `++ --` | 一元增量、减量操作符 | 整数、实数、短实数 |
| `inside` | 二进制集合成员操作符 | 左操作数的单数 |
| `dist` | 二进制分布操作符 | 整数 |
| `{} {{}}` | 连接、复制操作符 | 整数 |
| `{<<{}} {>>{}}` | 流操作符 | 整数 |

dist 操作符在 16.14.2 和 18.5.4 中描述。

### 11.3.1 具有实数操作数的操作符
表 11-1 显示了可以应用于实数操作数的操作符。

使用逻辑或关系操作符或 inside 操作符对实数操作数的结果应为单比特标量值。

对于其他操作符，如果任何操作数（条件操作符中的问号之前的除外）是 real，则结果为 real。否则，如果任何操作数（条件操作符中的问号之前的除外）是 shortreal，则结果为 shortreal。

实数操作数还可以用于以下表达式：
 - `str.realval // 结构或联合成员`
 - `realarray[intval] // 数组元素`

有关使用实数的更多信息，请参见 6.12.1。

### 11.3.2 操作符优先级
操作符优先级和结合性列在表 11-2 中。最高优先级首先列出。

表 11-2——操作符优先级和结合性
| 操作符 | 结合性 | 优先级 |
| :---: | :---: | :---: |
| `() [] :: .` | 左 | 最高 |
| `+ - ! ~ & ~& \| ~\| ^ ~^ ^~ ++ --（一元）` |  |  |
| `**` | 左 | |
| `* / %` | 左 | |
| `+ -（二进制）` | 左 | |
| `<< >> <<< >>>` | 左 | |
| `< <= > >= inside dist` | 左 | |
| `== != === !== ==? !=?` | 左 | |
| `&（二进制）` | 左 | |
| `^ ~^ ^~（二进制）` | 左 | |
| `\|（二进制）` | 左 | |
| `&&` | 左 | |
| `\|\|` | 左 | |
| `?:（条件操作符）` | 右 | |
| `–> <–>` | 右 | |
| `= += -= *= /= %= &= ^= \|= <<= >>= <<<= >>>= := :/ <=` | 无 |  |
| `{} {{}}` | 连接 | 最低 |

表 11-2 中显示的操作符应具有相同的优先级。行按操作符的优先级降序排列。例如，`* /` 和 `%` 的优先级相同，高于二进制 `+` 和 `-` 操作符的优先级。

所有操作符应该从左到右关联，除了条件（?:）、蕴含（->）和等价（<->）操作符，它们应该从右到左关联。关联性指的是具有相同优先级的操作符的计算顺序。因此，在以下示例中，B 被添加到 A，然后从 A+B 的结果中减去 C。
```verilog
A + B - C
```

当操作符的优先级不同时，具有更高优先级的操作符应首先关联。在以下示例中，B 被除以 C（除法的优先级高于加法），然后将结果添加到 A。
```verilog
A + B / C
```

可以使用括号更改操作符优先级。
```verilog
(A + B) / C // 与 A + B / C 不同
```

### 11.3.3 在表达式中使用整数字面量
整数字面量可以用作表达式中的操作数。整数字面量可以表示为以下内容：
 - 未定型、未基数的整数（例如，12）
 - 未定型、基数整数（例如，'d12，'sd12）
 - 有大小、基数整数（例如，16'd12，16'sd12）

有关整数字面量语法，请参见 5.7.1。

对于没有基数说明符的整数的负值，应该与具有基数说明符的整数有所不同。没有基数说明符的整数应该被解释为二进制补码形式的有符号值。具有无符号基数说明符的整数应该被解释为无符号值。

以下示例显示了写表达式“减 12 除以 3”的四种方法。请注意，-12 和 -'d12 都计算为相同的二进制补码位模式，但在表达式中，-'d12 失去了作为有符号负数的身份。
```verilog
int IntA;
IntA = -12 / 3; // 结果是 -4
IntA = -'d 12 / 3; // 结果是 1431655761
IntA = -'sd 12 / 3; // 结果是 -4
IntA = -4'sd 12 / 3; // -4'sd12 是 4 位数量 1100 的负值，即 -4。-(-4) = 4
// 结果是 1
```

### 11.3.4 对逻辑（4 状态）和位（2 状态）类型的操作
操作符可以应用于 2 状态值或混合 2 状态和 4 状态值。结果与将所有值视为 4 状态值时相同。在大多数情况下，如果所有操作数都是 2 状态，则结果在 2 状态值集中。唯一的例外是产生 x 结果的操作符，对于 2 状态值集中的操作数（例如，除以零）。
```verilog
int n = 8, zero = 0;
int res = 'b01xz | n; // res 得到 'b11xz 强制转换为 int，或 'b1100
int sum = n + n; // sum 得到 16 强制转换为 int，或 16
int sumx = 'x + n; // sumx 得到 'x 强制转换为 int，或 0
int div2 = n/zero + n; // div2 得到 'x 强制转换为 int，或 0
integer div4 = n/zero + n; // div4 得到 'x
```

### 11.3.5 操作符表达式短路
在计算表达式时，操作符应遵循结合性规则，如 11.3.2 中所述。某些操作符（&&、||、-> 和 ?:）应使用短路计算；换句话说，如果不需要它们的值来确定操作的最终值，则它们的某些操作数表达式将不被计算。每个操作符的详细短路行为在其相应的子句中描述（11.4.7 和 11.4.11）。所有其他操作符不应使用短路计算——它们的所有操作数表达式总是被计算。当发生短路时，由于计算短路操作数表达式而导致的任何副作用或运行时错误都不会发生。

例如：
```verilog
logic regA, regB, regC, result ;

function logic myFunc(logic x);
    ...
endfunction

result = regA & (regB | myFunc(regC)) ;
```

即使 regA 已知为零，子表达式 (regB | myFunc(regC)) 将被计算，并且由于调用 myFunc(regC) 而引起的任何副作用都将发生。

请注意，实现可以通过省略子表达式的计算来进行优化，只要模拟行为（包括副作用）就像遵循标准规则一样。

### 11.3.6 表达式中的赋值
表达式可以包括一个阻塞赋值，前提是它没有定时控制。这些阻塞赋值应该用括号括起来，以避免常见错误，例如使用 a=b 代替 a==b 或使用 a|=b 代替 a!=b。
```verilog
if ((a=b)) b = (a+=1);
a = (b = (c = 5));
```

这种赋值表达式的语义是一个函数，它计算右侧，将右侧强制转换为左侧数据类型，将其堆叠，更新左侧，然后返回堆叠的值。返回的值的数据类型是左侧的数据类型。如果左侧是一个连接，则返回的值的数据类型应该是一个无符号整数数据类型，其位长度是其操作数的长度之和。

在事件表达式、过程连续赋值内的表达式或不在过程语句内的表达式中包含赋值运算符是非法的。

## 11.4 操作符描述
### 11.4.1 赋值操作符
除了简单赋值操作符 = 外，SystemVerilog 还包括 C 赋值操作符和特殊的位赋值操作符：`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`、`<<<=` 和 `>>>=`。赋值操作符在语义上等同于阻塞赋值，唯一的例外是左侧索引表达式只计算一次。例如：
```verilog
a[i]+=2; // 与 a[i] = a[i] +2; 相同
```

### 11.4.2 增量和减量操作符
SystemVerilog 包括 C 增量和减量赋值操作符 `++i`、`--i`、`i++` 和 `i--`。在表达式中使用这些操作符时，不需要括号。这些增量和减量赋值操作符的行为类似于阻塞赋值。

在表达式中的赋值操作相对于表达式中的任何其他操作的顺序是未定义的。当在一个整数表达式中，或者在其他实现无法保证求值顺序的上下文中，写变量和读变量或写变量时，实现可以发出警告。例如：
```verilog
i = 10;
j = i++ + (i = i - 1);
```

执行后，j 的值可以是 18、19 或 20，具体取决于增量和赋值语句的相对顺序。

如果实数操作数应用于实数操作符，则操作数将增加或减少 1.0。

### 11.4.3 算术操作符
二进制算术操作符列在表 11-3 中。
表 11-3—定义的算术操作符
| 表达式 | 说明 |
| :---: | :---: |
| `a + b` | a 加 b |
| `a - b` | a 减 b |
| `a * b` | a 乘以 b（或 a 乘 b） |
| `a / b` | a 除以 b |
| `a % b` | a 模 b |
| `a ** b` | a 的 b 次幂 |

整数除法应将任何小数部分向零截断。对于除法或模数操作符，如果第二个操作数为零，则整个结果值应为 x。模数操作符（例如，`a%b`）在第一个操作数被第二个操作数整除时给出余数，因此当 b 完全除尽 a 时为零。模数操作的结果应取第一个操作数的符号。

如果幂运算符的任一操作数是实数，则结果类型应为实数（见 11.3.1）。如果第一个操作数为零且第二个操作数为非正数，或者第一个操作数为负数且第二个操作数不是整数值，则幂运算符的结果是未指定的。

如果幂运算符的两个操作数都不是实数，则结果类型应根据 11.6.1 和 11.8.1 中概述的确定。如果第一个操作数为零且第二个操作数为负数，则结果值为 'x。如果第二个操作数为零，则结果值为 1。

在所有情况下，幂运算符的第二个操作数应被视为自决定。

这些语句在表 11-4 中进行了说明。

表 11-4—幂运算符规则
| | op1 是负数 < -1 | op1 是 -1 | op1 是零 | op1 是 1 | op1 是正数 > 1 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| op2 是正数 | op1 ** op2 | op2 是奇数 -> -1<br>op2 是偶数 -> 1 | 0 | 1 | op1 ** op2 |
| op2 是零 | 1 | 1 | 1 | 1 | 1 |
| op2 是负数 | 0 | op2 是奇数 -> -1<br>op2 是偶数 -> 1 | 'x | 1 | 0 |

一元算术操作符应优先于二进制操作符。一元操作符列在表 11-5 中。

表 11-5—定义的一元操作符
| `+m` | 一元加 m（与 m 相同） |
| --- | --- |
| `-m` | 一元减 m |

对于算术操作符，如果任何操作数位值是未知值 x 或高阻值 z，则整个结果值应为 x。

表 11-6 给出了一些模数和幂运算的示例。

表 11-6—模数和幂运算符示例
| 表达式 | 结果 | 说明 |
| :---: | :---: | :---: |
| `10 % 3` | 1 | 10/3 产生余数 1 |
| `11 % 3` | 2 | 11/3 产生余数 2 |
| `12 % 3` | 0 | 12/3 产生没有余数 |
| `-10 % 3` | -1 | 结果取第一个操作数的符号 |
| `11 % -3` | 2 | 结果取第一个操作数的符号 |
| `-4'd12 % 3` | 1 | -4'd12 被视为一个大正数，当除以 3 时，余数为 1 |
| `3 ** 2` | 9 | 3 × 3 |
| `2 ** 3` | 8 | 2 × 2 × 2 |
| `2 ** 0` | 1 | 任何数的零次幂都是 1 |
| `0 ** 0` | 1 | 0 的零次幂也是 1 |
| `2.0 ** -3'sb1` | 0.5 | 2.0 是实数，给出实数的倒数 |
| `2 ** -3 'sb1` | 0 | 2 ** -1 = 1/2。整数除法截断为零 |
| `0 ** -1` | `'x` | 0 ** -1 = 1/0。整数除以零是 'x |
| `9 ** 0.5` | 3.0 | 实数平方根 |
| `9.0 ** (1/2)` | 1.0 | 整数除法将指数截断为零 |
| `-3.0 ** 2.0` | 9.0 | 定义为实数 2.0 仍然是整数值 |

#### 11.4.3.1 有符号和无符号类型的算术表达式
线网和变量可以显式声明为无符号或有符号。byte、shortint、int、integer 和 longint 数据类型默认为有符号。其他数据类型默认为无符号。

分配给无符号变量或线网的值应被视为 *无符号* 值。分配给有符号变量或线网的值应被视为 *有符号* 值。有符号值，除了分配给实数变量的值，应使用二进制补码表示。分配给实数变量的值应使用浮点表示。有符号和无符号值之间的转换应保持相同的位表示；只有解释发生变化。

表 11-7 列出了算术操作符如何解释每种数据类型。

表 11-7—算术操作符的数据类型解释
| 数据类型 | 解释 |
| :---: | :---: |
| 无符号线网 | 无符号 |
| 有符号线网 | 有符号、二进制补码 |
| 无符号变量 | 无符号 |
| 有符号变量 | 有符号、二进制补码 |
| 实数变量 | 有符号、浮点 |

以下示例显示了使用整数和逻辑变量在表达式中“减 12 除以 3”的各种方法。

```verilog
integer intS;
var logic [15:0] U;
var logic signed [15:0] S;

intS = -4'd12;
U = intS / 3; // 表达式结果是 -4，intS 是整数数据类型，U 是 65532

U = -4'd12; // U 是 65524
intS = U / 3; // 表达式结果是 21841，U 是逻辑数据类型

intS = -4'd12 / 3; // 表达式结果是 1431655761。-4'd12 实际上是一个 32 位逻辑数据类型

U = -12 / 3; // 表达式结果是 -4，-12 实际上是一个整数数据类型。U 是 65532

S = -12 / 3; // 表达式结果是 -4。S 是一个有符号逻辑

S = -4'sd12 / 3; // 表达式结果是 1。-4'sd12 实际上是 4。整数除法规则产生 4/3==1
```

### 11.4.4 关系操作符
表 11-8 列出并定义了关系操作符。

表 11-8—关系操作符定义
| a < b | a 小于 b |
| --- | --- |
| a > b | a 大于 b |
| a <= b | a 小于或等于 b |
| a >= b | a 大于或等于 b |

使用这些 *关系操作符* 的表达式应在指定关系为假时产生标量值 0，或在为真时产生值 1。如果关系操作符的任一操作数包含未知值（x）或高阻值（z），则结果应为 1 位未知值（x）。

当关系表达式的一个或两个操作数是无符号时，应将表达式解释为无符号值之间的比较。如果操作数的位长度不同，则较小的操作数应被零扩展到较大操作数的大小。

当两个操作数都是有符号时，应将表达式解释为有符号值之间的比较。如果操作数的位长度不同，则较小的操作数应被符号扩展到较大操作数的大小。有关更多信息，请参见 11.8.2。

如果一个操作数是实数操作数，则另一个操作数应转换为等效的实数值，并且表达式应解释为实数值之间的比较。

所有关系操作符应具有相同的优先级。关系操作符的优先级低于算术操作符。

以下示例说明了这种优先级规则的含义：
```verilog
a < b - 1 // 这个表达式与
a < (b - 1) // 这个表达式相同，但是 . . .
b - (1 < a) // 这个不同于
b - 1 < a // 这个表达式
```

当 b - (1 < a) 计算时，关系表达式首先计算，然后从 b 中减去零或一。当 `b-1<a` 计算时，b 操作数的值减少 1，然后与 a 比较。

### 11.4.5 相等操作符
*相等操作符* 的优先级低于关系操作符。表 11-9 列出并定义了相等操作符。

表 11-9—相等操作符定义
| a === b | a 等于 b，包括 x 和 z |
| --- | --- |
| a !== b | a 不等于 b，包括 x 和 z |
| a == b | a 等于 b，结果可能未知 |
| a != b | a 不等于 b，结果可能未知 |

这四个相等操作符应具有相同的优先级。这四个操作符按位比较操作数。如果比较失败，则结果应为 0，如果成功，则结果应为 1。

当一个或两个操作数是无符号时，应将表达式解释为无符号值之间的比较。如果操作数的位长度不同，则较小的操作数应被零扩展到较大操作数的大小。

当两个操作数都是有符号时，应将表达式解释为有符号值之间的比较。如果操作数的位长度不同，则较小的操作数应被符号扩展到较大操作数的大小。有关更多信息，请参见 11.8.2。

如果一个操作数是实数操作数，则另一个操作数应转换为等效的实数值，并且表达式应解释为实数值之间的比较。

逻辑相等（或 case 相等）操作符是一个合法操作，如果其中一个操作数是类句柄或字面值 null，并且一个操作数与另一个操作数的赋值兼容。逻辑相等（或 case 相等）操作符是一个合法操作，如果其中一个操作数是 `chandle` 或字面值 null。在这两种情况下，操作符比较类句柄、接口类句柄或 `chandle` 的值。

对于 *逻辑相等* 和 *逻辑不等* 操作符（== 和 !=），如果由于操作数中的未知或高阻值导致关系不明确，则结果应为 1 位未知值（x）。

对于 *case 相等* 和 *case 不等* 操作符（=== 和 !==），比较应该像过程性 case 语句中一样进行（见 12.5）。操作数中的 x 或 z 位应包括在比较中，并且应匹配以使结果被视为相等。这些操作符的结果应始终是已知值，要么是 1，要么是 0。

### 11.4.6 通配符相等操作符
*通配符相等操作符* 的优先级与相等操作符相同。表 11-10 列出并定义了通配符相等操作符。

表 11-10—通配符相等和通配符不等操作符
| 操作符 | 用法 | 说明 |
| :---: | :---: | :---: |
| `==?` | `a ==? b` | a 等于 b，b 中的 X 和 Z 值作为通配符 |
| `!=?` | `a !=? b` | a 不等于 b，b 中的 X 和 Z 值作为通配符 |

通配符相等操作符和通配符不等操作符（==? 和 !=?）将 b 中的 X 和 Z 值视为通配符。在比较的相应位中，通配符位匹配任何位值（0、1、Z 或 X）。其他位将像逻辑相等和逻辑不等操作符一样进行比较。

这些操作符按位比较操作数，并返回一个 1 位自决定结果。如果通配符相等/不等的操作数位长度不同，则操作数将以与逻辑相等/不等操作符相同的方式扩展。如果关系是真，则操作数将返回 1。如果关系是假，则操作数将返回 0。如果关系是未知，则操作数将返回 X。

SystemVerilog 中的不同类型的相等（和不等）操作符在其处理包含未知值（X 或 Z）的操作数时的行为不同。== 和 != 操作符可能会导致 x，如果它们的任何操作数包含 X 或 Z。=== 和 !== 操作符明确检查 4 状态值；因此，X 和 Z 值将匹配或不匹配，永远不会导致 X。==? 和 !=? 操作符可能会导致 X，如果左操作数包含未知值 x 或 Z，而右操作数中没有与之匹配的通配符。

通配符相等操作符等同于逻辑相等操作符，如果它们的操作数是类句柄、接口类句柄、chandle 或字面值 null。

### 11.4.7 逻辑操作符
操作符 *逻辑 AND*（&&）、*逻辑 OR*（||）、*逻辑蕴含*（->）和*逻辑等价*（<->）是逻辑连接符。逻辑操作的计算结果应为 1（定义为真）、0（定义为假）或，如果结果不明确，则为未知值（x）。&& 的优先级高于 ||，两者都低于关系和相等操作符。-> 和 <-> 的优先级相同，操作数之间的绑定由结合性（右）控制，两者都低于其他逻辑操作符和条件操作符。

逻辑蕴含表达式1 -> 表达式2 在逻辑上等价于 (!表达式1 || 表达式2)，逻辑等价表达式1 <-> 表达式2 在逻辑上等价于 ((表达式1 -> 表达式2) && (表达式2 -> 表达式1))。逻辑等价操作符的两个操作数都应被计算一次。

一元 *逻辑否定操作符*（!）将非零或真操作数转换为 0，将零或假操作数转换为 1。不明确的真值保留为 x。

示例 1：如果变量 alpha 包含整数值 237，beta 包含值零，则以下示例执行如下：
```verilog
regA = alpha && beta; // regA 设置为 0
regB = alpha || beta; // regB 设置为 1
```

示例 2：以下表达式执行三个子表达式的逻辑与，而不需要任何括号：
```verilog
a < size-1 && b != c && index != lastone
```

然而，出于可读性的目的，建议使用括号来非常清楚地显示所需的优先级，如下面对此示例的重写所示：
```verilog
(a < size-1) && (b != c) && (index != lastone)
```

示例 3：! 在以下构造中的常见用法：
```verilog
if (!inword)
```

在某些情况下，前面的构造对于阅读代码的人来说更有意义，而不是这个等价构造：
```verilog
if (inword == 0)
```

&& 和 || 操作符应使用短路计算，如下所示：
- 第一个操作数表达式应始终被计算。
- 对于 &&，如果第一个操作数值逻辑上为假，则不应计算第二个操作数。
- 对于 ||，如果第一个操作数值逻辑上为真，则不应计算第二个操作数。

### 11.4.8 位操作符
*位操作符* 应在操作数上执行位操作；也就是说，操作符应将一个操作数中的一个位与另一个操作数中的相应位结合以计算结果位。表 11-11 到表 11-15 显示了每种可能计算的结果。

表 11-11—位二进制 AND 操作符
| `&` | 0 | 1 | x | z |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | x | x |
| x | 0 | x | x | x |
| z | 0 | x | x | x |

表 11-12—位二进制 OR 操作符
| `\|` | 0 | 1 | x | z |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 1 | x | x |
| 1 | 1 | 1 | 1 | 1 |
| x | x | 1 | x | x |
| z | x | 1 | x | x |

表 11-13—位二进制异或操作符
| `^` | 0 | 1 | x | z |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 1 | x | x |
| 1 | 1 | 0 | x | x |
| x | x | x | x | x |
| z | x | x | x | x |

表 11-14—位二进制异或非操作符
| `^~` 或 `~^` | 0 | 1 | x | z |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 1 | 0 | x | x |
| 1 | 0 | 1 | x | x |
| x | x | x | x | x |
| z | x | x | x | x |

表 11-15—位一元否定操作符
| `~` | |
| :---: | --- |
| 0 | 1 |
| 1 | 0 |
| x | x |
| z | x |

### 11.4.9 缩减操作符
*一元缩减操作符* 应在单个操作数上执行位操作，以产生单个位结果。对于 *缩减 AND*、*缩减 OR* 和 *缩减 XOR* 操作符，操作的第一步应使用表 11-16 到表 11-18 之间的表格在第一个操作数的第一个位和第二个操作数之间应用操作符。第二步和后续步骤应使用相同的逻辑表在前一步的 1 位结果和下一个操作数之间应用操作符。对于 *缩减 NAND*、*缩减 NOR* 和 *缩减 XNOR* 操作符，结果应通过反转缩减 AND、缩减 OR 和缩减 XOR 操作的结果来计算。

表 11-16—缩减一元 AND 操作符
| `&` | 0 | 1 | x | z |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | x | x |
| x | 0 | x | x | x |
| z | 0 | x | x | x |

表 11-17—缩减一元 OR 操作符
| `\|` | 0 | 1 | x | z |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 1 | x | x |
| 1 | 1 | 1 | 1 | 1 |
| x | x | 1 | x | x |
| z | x | 1 | x | x |

表 11-18—缩减一元异或操作符
| `^` | 0 | 1 | x | z |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | 1 | x | x |
| 1 | 1 | 0 | x | x |
| x | x | x | x | x |
| z | x | x | x | x |

例如，表 11-19 显示了在不同操作数上应用缩减操作符的结果。

表 11-19—缩减操作的结果
| 操作数 | `&` | `~&` | `\|` | `~\|` | `^` | `~^` | 说明 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 4'b0000 | 0 | 1 | 0 | 1 | 0 | 1 | 没有位设置 |
| 4'b1111 | 1 | 0 | 1 | 0 | 0 | 1 | 所有位设置 |
| 4'b0110 | 0 | 1 | 1 | 0 | 0 | 1 | 位数为偶数 |
| 4'b1000 | 0 | 1 | 1 | 0 | 1 | 0 | 位数为奇数 |

### 11.4.10 移位操作符
有两种类型的 *移位操作符*：*逻辑移位操作符*（<< 和 >>）和*算术移位操作符*（<<< 和 >>>）。左移操作符（<< 和 <<<）应将其左操作数向左移动右操作数指定的位数。在这两种情况下，空出的位位置应填充为零。右移操作符（>> 和 >>>）应将其左操作数向右移动右操作数指定的位数。逻辑右移应用零填充到空出的位位置。算术右移应用零填充到空出的位位置，如果结果类型是无符号的，则应用零填充到空出的位位置。如果结果类型是有符号的，则应用左操作数的最高位（即，符号位）的值填充空出的位位置。如果右操作数具有 x 或 z 值，则结果应为未知。右操作数始终被视为无符号数，并且不会影响结果的符号。结果的符号由左操作数和表达式的其余部分确定，如 11.8.1 中所述。

示例 1：在这个示例中，变量 result 被赋予二进制值 0100，这是 0001 向左移动两个位置并用零填充的结果。
```verilog
module shift;
    logic [3:0] start, result;
    initial begin
        start = 1;
        result = (start << 2);
    end
endmodule
```

示例 2：在这个示例中，变量 result 被赋予二进制值 1110，这是 1000 向右移动两个位置并用符号填充的结果。
```verilog
module ashift;
    logic signed [3:0] start, result;
    initial begin
        start = 4'b1000;
        result = (start >>> 2);
    end
endmodule
```

### 11.4.11 条件操作符
*条件操作符* 应是右结合的，并应使用两个操作符和三个操作数构造，用语法 11-2 所示的形式。
---
```verilog
conditional_expression ::= // from A.8.3
cond_predicate ? { attribute_instance } expression : expression 
cond_predicate ::= // from A.6.6
expression_or_cond_pattern { &&& expression_or_cond_pattern }
expression_or_cond_pattern ::= 
expression | cond_pattern 
cond_pattern ::= expression matches pattern 
```
---
语法 11-2—条件操作符语法（从附录 A 中摘录）

这节描述了传统的条件操作符，其中 cond_predicate 只是一个单一的表达式。SystemVerilog 还允许 cond_predicate 执行模式匹配，这在 12.6 中描述。

如果 cond_predicate 为真，则操作符返回第一个表达式的值，而不计算第二个表达式；如果为假，则返回第二个表达式的值，而不计算第一个表达式。如果 cond_predicate 评估为不明确的值（x 或 z），则应计算第一个表达式和第二个表达式，并按照 11.4.5 中描述的逻辑等价性进行比较。如果比较为真（1），则操作符应返回第一个或第二个表达式。否则，操作符应根据表达式的数据类型返回结果。

当第一个和第二个表达式都是整数类型时，如果 cond_predicate 评估为不明确的值，并且表达式不是逻辑等价的，则应使用表 11-20 计算位的结果来计算最终结果。首先，第一个和第二个表达式应扩展到相同的宽度，如 11.6.1 和 11.8.2 中所述。

表 11-20—条件操作符的不明确条件结果
| `?:` | 0 | 1 | x | z |
| :---: | :---: | :---: | :---: | :---: |
| 0 | 0 | x | x | x |
| 1 | x | 1 | x | x |
| x | x | x | x | x |
| z | x | x | x | x |

下面是一个三态输出总线的示例，说明了条件操作符的常见用法：
```verilog
wire [15:0] busa = drive_busa ? data : 16'bz;
```

当 drive_busa 为 1 时，称为 data 的总线被驱动到 busa 上。如果 drive_busa 是未知的，则未知值被驱动到 busa 上。否则，busa 不被驱动。

条件操作符可以与非整数类型（见 6.11.1）和聚合表达式（见 11.2.2）一起使用，使用以下规则：
 - 如果第一个表达式和第二个表达式都是整数类型，则操作按照定义进行。
 - 如果两个表达式都是实数，则结果类型为实数。如果一个表达式是实数，另一个表达式是 shortreal 或整数，则将另一个表达式转换为实数，并且结果类型为实数。如果一个表达式是 shortreal，另一个表达式是整数，则将整数表达式转换为 shortreal，并且结果类型为 shortreal。
 - 否则，如果第一个表达式或第二个表达式是整数类型，并且对方表达式可以隐式转换为整数类型，则进行转换并按照定义进行。
 - 如果第一个表达式或第二个表达式是类或接口类数据类型，则在以下情况下，条件表达式是合法的：
   - 如果第一个表达式和第二个表达式都是字面值 null，则整个条件表达式的结果就像表达式是字面值 null 一样。
   - 否则，如果第一个表达式或第二个表达式是字面值 null，则结果类型是非空表达式的类型。
   - 否则，如果第一个表达式与第二个表达式的赋值兼容，则结果类型是第二个表达式的类型。
   - 否则，如果第二个表达式与第一个表达式的赋值兼容，则结果类型是第一个表达式的类型。
   - 否则，如果第一个表达式和第二个表达式是从共同基类类型继承的类类型，则结果类型是最接近的公共继承类类型。
   在前面的情况下，如果条件评估为 TRUE，则结果值是第一个表达式的值，如果条件评估为 FALSE，则结果值是第二个表达式的值。
 - 对于所有其他情况，第一个表达式和第二个表达式的类型应等效（见 6.22.2）。

对于非整数和聚合表达式，如果 cond_predicate 评估为不明确的值，并且表达式不是逻辑等价的，则：
 - 对于聚合数组数据类型，除关联数组外，如果两个表达式包含相同数量的元素，则它们的结果应逐个元素组合。如果元素匹配，则应返回元素。如果它们不匹配，则应返回表 7-1 中为该元素类型指定的值。
 - 对于所有其他数据类型，应返回表 7-1 中为所得类型指定的值。




